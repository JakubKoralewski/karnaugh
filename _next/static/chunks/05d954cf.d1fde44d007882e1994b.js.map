{"version":3,"sources":["webpack:///./node_modules/framer-motion/dist/framer-motion.es.js"],"names":["isFloat","value","isNaN","parseFloat","MotionValue","init","_a","_this","this","_b","transformer","parent","timeDelta","lastUpdated","canTrackVelocity","updateAndNotify","v","render","prev","current","updateSubscribers","forEach","notifySubscriber","children","setChild","renderSubscribers","delta","timestamp","postRender","scheduleVelocityCheck","subscriber","velocityCheck","child","set","prototype","addChild","config","Set","add","removeChild","delete","subscribeTo","subscriptions","subscription","updateSubscriber","onChange","onRenderRequest","attach","passiveEffect","get","getVelocity","start","animation","stop","Promise","resolve","stopAnimation","then","clearAnimation","isAnimating","destroy","clear","motionValue","opts","useConstant","ref","resolver","isMotionValue","updateStyler","onRead","onRender","state","onUpdate","MotionValuesMap","hasMounted","values","Map","unsubscribers","has","key","bindValueToOutput","defaultValue","undefined","callback","unsubscribeOnRender","output","unsubscribeOnChange","setOnUpdate","setTransformTemplate","transformTemplate","updateTransformTemplate","getTransformTemplate","mount","unmount","_value","unsubscribe","specialMotionValueProps","useMotionValues","props","motionValues","map","session","syncRenderSession","styler","push","Mount","innerRef","isStatic","Element","domStyler","preparseOutput","enableHardwareAcceleration","resolveCurrent","resolvedValues","transformOriginProps","isTransformOriginProp","buildStyleAttr","styleProp","motionValueStyles","transform","useMotionStyles","transformValues","style","prevMotionStyles","thisStyle","isKeyframesTarget","Array","isArray","resolveFinalValueInKeyframes","length","dimensionTypes","test","parse","valueTypes","testValueType","type","getDimensionValueType","find","getValueType","underDampedSpring","stiffness","damping","restDelta","restSpeed","overDampedSpring","to","linearTween","ease","duration","keyframes","defaultTransitions","x","y","z","rotate","rotateX","rotateY","rotateZ","scaleX","scaleY","scale","opacity","backgroundColor","color","default","just","update","complete","easingDefinitionToFunction","definition","x1","y1","x2","y2","isEasingArray","isAnimatable","startsWith","secondsToMilliseconds","seconds","transitions","tween","spring","inertia","transitionOptionParser","from","velocity","easings","getTransitionDefinition","transitionDefinition","delay","when","delayChildren","staggerChildren","staggerDirection","transition","Object","keys","isTransitionDefined","valueKey","transitionFactory","getDefaultTransition","valueTransitionDefinition","hasOwnProperty","getAnimation","target","origin","isOriginAnimatable","isTargetAnimatable","actionFactory","preprocessOptions","repeatDelay","startAnimation","delay$1","activeAnimation","animationFactory","valueDelay","options","animate","ValueAnimationControls","readValueFromSource","makeTargetAnimatable","variants","baseTarget","overrides","resolvedOverrides","activeOverrides","hasValue","setProps","setVariants","setDefaultTransition","defaultTransition","setValues","_c","isActive","priority","_d","resolveVariant","transitionEnd","targetValue","checkForNewValues","newValueKeys","filter","numNewValues","i","getAnimatableNone","variant","custom","getCurrent","getHighestPriority","size","Math","max","apply","setOverride","overrideIndex","startOverride","override","clearOverride","highest","resetIsAnimating","overrideTarget","remainingValues","onStart","onComplete","applyVariantLabels","variantLabelList","reverse","animateVariantLabels","animateVariant","animationDefinition","transitionOverride","_e","animatable","animations","valueTarget","allAnimations","all","variantLabels","label","variantLabel","getAnimations","getChildrenAnimations","animateChildren","last","first","maxStaggerDuration","generateStaggerDuration","childControls","onAnimationStart","onAnimationComplete","checkOverrideIsAnimating","numOverrides","resolvedOverride","controls","resetChildren","AnimationControls","pendingAnimations","componentControls","subscribe","animations_1","PresenceContext","MotionContext","static","isVariantLabel","isAnimationControls","useMotionContext","parentContext","initialState","initial","whileTap","whileHover","presenceContext","shouldPropagateControls","targetInitial","targetAnimate","initialDependency","animateDependency","context","isReducedMotion","isInitialOnly","isInitialRender","useInitialOrEveryRender","initialToApply","useValueAnimationControls","subscribeToParentControls","parentControls","isPresent","unmountProps","checkShouldInheritVariant","inherit","createMotionComponent","getValueControlsConfig","loadFunctionalityComponents","renderComponent","externalRef","useExternalRef","shouldInheritVariant","functionality","renderedComponent","Provider","svgElements","MotionPluginContext","transformPagePoint","p","useUnmountEffect","addDomEvent","eventName","handler","addEventListener","removeEventListener","isMouseEvent","event","PointerEvent","pointerType","MouseEvent","isTouchEvent","touches","defaultPagePoint","pageX","pageY","pointFromTouch","e","changedTouches","pointFromMouse","extractEventInfo","point","Point","wrapHandler","shouldFilterPrimaryPointer","listener","eventHandler","button","filterPrimaryPointer","isBrowser","window","supportsPointerEvents","onpointerdown","supportsTouchEvents","ontouchstart","supportsMouseEvents","onmousedown","mouseEventNames","pointerdown","pointermove","pointerup","pointercancel","pointerover","pointerout","pointerenter","pointerleave","touchEventNames","getPointerEventName","name","addPointerEvent","usePointerEvent","element","useDomEvent","subtract","a","b","relativeTo","idOrElem","elem","localElem","document","getElementById","rect","getBoundingClientRect","left","scrollX","top","scrollY","isViewportScrollBlocked","preventDefault","passive","unblockViewportScroll","PanSession","handlers","startEvent","lastMoveEvent","lastMoveEventInfo","updatePoint","info","getPanInfo","history","isPanStarted","isDistancePastThreshold","offset","onMove","initialInfo","transformPoint","onSessionStart","removeOnPointerMove","handlePointerMove","removeOnPointerUp","handlePointerUp","removeListeners","buttons","end","onEnd","panInfo","updateHandlers","lastDevicePoint","startDevicePoint","getVelocity$1","timestampedPoint","lastPoint","time","currentVelocity","Infinity","isNodeOrChild","parentElement","order","getGesturePriority","gesture","indexOf","createLock","lock","globalHorizontalLock","globalVerticalLock","getGlobalLock","drag","openHorizontal_1","openVertical_1","tapGesturePriority","hoverPriority","filterTouch","useGestures","onPan","onPanStart","onPanEnd","onPanSessionStart","hasPanEvents","panSession","usePanGesture","onTap","onTapStart","onTapCancel","hasTapListeners","isTapping","cancelPointerEventListener","removePointerUp","onPointerUp","openGestureLock","useTapGesture","onHoverStart","onHoverEnd","useHoverGesture","makeRenderlessComponent","hook","gestureProps","Gestures","shouldRender","some","Component","isRefObject","noop","ComponentDragControls","isDragging","currentDirection","constraints","openGlobalLock","prevConstraintsBox","width","height","originEvent","snapToCursor","bothAxis","axis","axisPoint","constraintsNeedResolution","dragConstraints","transformPagePoint_1","calculateConstraintsFromDom","applyConstraintsToPoint","dragPropagation","onDragStart","convertPanToDrag","dragDirectionLock","lockThreshold","direction","abs","getCurrentDirection","onDirectionLock","onDrag","cancelDrag","dragMomentum","dragElastic","onDragEnd","animateDragEnd","recordBoxInfo","right","bottom","top_1","boundingBox","getBoundingBox","center","setPoint","shouldDrag","applyConstraints","updateProps","_f","_g","remainingProps","_dragValueX","_dragValueY","dragOriginX","dragOriginY","dragTransition","_dragTransitionControls","momentumAnimations","getConstraints","bounceStiffness","bounceDamping","animationControls","timeConstant","externalAxisMotionValue","scalePoint","onDragTransitionEnd","constraintsBox","draggableBox","scaleAxisPoint","dimension","pointToScale","stopPointerListener","dragListener","stopResizeListener","min","constraintsRef","draggableRef","parentBoundingBox","draggableBoundingBox","getCurrentOffset","constrainedValue","applyOverdrag","dragFactor","Drag","groupDragControls","dragControls","useDrag","isCSSVariable","cssVariableRegex","maxDepth","getVariableValue","depth","match","exec","parseCSSVariable","token","fallback","resolved","getComputedStyle","getPropertyValue","BoundingBoxDimension","positionalKeys","isPositionalKey","hasPositionalKey","setAndResetVelocity","isNumOrPxType","getPosFromMatrix","matrix","pos","split","getTranslateFromMatrix","pos2","pos3","_bbox","matrix3d","transformKeys","nonTranslationalTransformKeys","positionalValues","checkAndConvertChangedValueTypes","elementStyler","targetPositionalKeys","removedTransformValues","hasAttemptedToRemoveTransformValues","changedValueTypeKeys","reduce","acc","toType","fromType","numKeyframes","removedTransforms","removeNonTranslationalTransform","convertedTarget","changedKeys","originBbox","elementComputedStyle","display","originComputedStyle","targetBbox","convertChangedValueTypes","parseDomVariant","HTMLElement","resolveCSSVariables","unitConversion","useForceUpdate","forcedRenderCount","setForcedRenderCount","StepName","SyncLayoutContext","jobs","Prepare","Read","Render","jobsNeedProcessing","flushCallbackList","list","numJobs","createUseSyncEffect","stepName","layoutSync","flush","prepare","read","defaultLayoutTransition","defaultPositionTransition","axisLabels","id","centerOf","calcAxisDelta","next","names","sizeDelta","getLayout","measure","offsetLeft","offsetTop","offsetWidth","offsetHeight","readPositionStyle","position","isSizeKey","AnimatePropType","Layout","positionTransition","layoutTransition","_super","LayoutAnimation","arguments","getSnapshotBeforeUpdate","isHTMLElement","compare","getTransition","isPositionOnly","positionStyle","nextPosition","getLayoutType","calcDelta","originX","originY","isResolver","makeTransition","layoutKey","transformKey","visualOrigin","deltaKey","baseTransition","getDefaultLayoutTransition","offsetToApply","componentDidUpdate","contextType","validMotionProps","isValidMotionProp","hasUpdated","prevLength","shallowCompare","targetWithoutTransition","mergeTransitionEnd","_a$1","resolveVariantLabels","unresolvedVariant","asDependencyList","join","hasVariantChanged","oldVariant","newVariant","AnimatePropComponents","Target","targetAndTransition","prevValues","targetToAnimate","animatingTarget","finalTarget","shouldAnimateOnMount","isValidValue","valueHasUpdated","useAnimateProp","VariantLabel","targetVariants","parentAlreadyMounted","shouldAnimate","useVariants","AnimationSubscription","useAnimationGroupSubscription","isAnimationSubscription","animationProps","animatePropTypeTests","prop","getAnimationComponent","animatePropType","Exit","exit","onExitComplete","register","usePresence","isPlayingExitAnimation","isPropValid","emotionIsPropValid_1","buildHTMLProps","isDrag","userSelect","draggable","buildSVGProps","functionalityComponents","numFunctionalityComponents","createDomMotionConfig","isDOM","isSVG","forwardedProps","domProps","filterValidProps","staticVisualStyles","activeComponents","Animation","Component_1","htmlMotionComponents","svgMotionComponents","motion","DragControls","nativeEvent","PresenceChild","numPresenceChildren","numExitComplete","allComplete","getChildKey","AnimatePresence","exitBeforeEnter","localForceUpdate","forceUpdate","filteredChildren","filtered","onlyElements","presentChildren","allChildren","exiting","updateChildLookup","childrenToRender","presentKeys","targetKeys","numPresent","insertionIndex","splice","removeIndex","findIndex","prefersReducedMotion","matchMedia","motionMediaQuery_1","setReducedMotionPreferences","matches","addListener"],"mappings":"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xB,EAAUoC,GAC1E,IAAIkb,EAAmB,GAEnBC,EAAYzB,GAAsBjoB,GAClC0pB,GACAD,EAAiBnpB,KAAK,wBAAcopB,EAAW,CAAE7qB,IAAK,YAAaqO,QAASlN,EAAMkN,QAAS3F,QAASvH,EAAMuH,QAASI,SAAU3H,EAAM2H,SAAU3B,WAAYhG,EAAMgG,WAAYmG,SAAUA,EAAUoC,QAASA,EAAS9P,OAAQA,KAE7N,IAAK,IAAIwK,EAAI,EAAGA,EAAIggB,GAA4BhgB,IAAK,CACjD,IAAI7O,EAAK4uB,GAAwB/f,GAAIyP,EAAete,EAAGse,aAAc7Z,EAAMzE,EAAGyE,IAAK8qB,EAAcvvB,EAAGwe,UAChGF,EAAa1Y,EAAO2N,IACpB8b,EAAiBnpB,KAAK,wBAAcqpB,EAAa,YAAS,CAAE9qB,IAAKA,GAAOmB,EAAO,CAAEgN,cAAeW,EAASlP,OAAQA,EAAQ0N,SAAUA,EAAU3L,SAAUzC,MAG/J,OAAO0rB,GAEXhb,uBAAwB,SAAU1Q,EAAKU,GACnC,MAAO,CACHA,OAAQA,EACRgJ,oBAAqB,SAAU5I,GAC3B,OAAO,YAAOd,EAAI9C,SAAS8B,IAAI8B,IAKnC6I,qBAAsB4Z,GAAgB7iB,EAAQV,MAM9D,IAAI6rB,GAx0Ee,CACf,IACA,OACA,UACA,OACA,UACA,QACA,QACA,IACA,OACA,MACA,MACA,MACA,aACA,OACA,KACA,SACA,SACA,UACA,OACA,OACA,MACA,WACA,OACA,WACA,KACA,MACA,UACA,MACA,SACA,MACA,KACA,KACA,KACA,QACA,WACA,aACA,SACA,SACA,OACA,KACA,KACA,KACA,KACA,KACA,KACA,OACA,SACA,SACA,KACA,OACA,IACA,SACA,MACA,QACA,MACA,MACA,SACA,QACA,SACA,KACA,OACA,OACA,MACA,OACA,OACA,WACA,OACA,QACA,MACA,WACA,SACA,KACA,WACA,SACA,SACA,IACA,QACA,UACA,MACA,WACA,IACA,KACA,KACA,OACA,IACA,OACA,SACA,UACA,SACA,QACA,SACA,OACA,SACA,QACA,MACA,UACA,MACA,QACA,QACA,KACA,WAC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","file":"static/chunks/05d954cf.d1fde44d007882e1994b.js","sourcesContent":["import { __assign, __spreadArrays, __rest, __extends } from 'tslib';\nimport { useRef, memo, useEffect, createContext, useContext, useMemo, forwardRef, createElement, Fragment, useCallback, useState, Component, cloneElement, Children, isValidElement } from 'react';\nimport sync, { getFrameData, cancelSync } from 'framesync';\nimport { velocityPerSecond, distance, mix, interpolate, wrap } from '@popmotion/popcorn';\nimport styler, { createStylerFactory, buildStyleProperty, isTransformProp, transformProps, buildSVGAttrs } from 'stylefire';\nimport { invariant, warning } from 'hey-listen';\nimport { color, complex, number, px, percent, degrees, vw, vh } from 'style-value-types';\nimport { action, delay, tween, spring, keyframes as keyframes$1, inertia } from 'popmotion';\nimport * as easingLookup from '@popmotion/easing';\nimport { cubicBezier, linear } from '@popmotion/easing';\n\nvar isFloat = function (value) {\r\n    return !isNaN(parseFloat(value));\r\n};\r\n/**\r\n * `MotionValue` is used to track the state and velocity of motion values.\r\n *\r\n * @public\r\n */\r\nvar MotionValue = /** @class */ (function () {\r\n    /**\r\n     * @param init - The initiating value\r\n     * @param config - Optional configuration options\r\n     *\r\n     * -  `transformer`: A function to transform incoming values with.\r\n     *\r\n     * @internal\r\n     */\r\n    function MotionValue(init, _a) {\r\n        var _this = this;\r\n        var _b = _a === void 0 ? {} : _a, transformer = _b.transformer, parent = _b.parent;\r\n        /**\r\n         * Duration, in milliseconds, since last updating frame.\r\n         *\r\n         * @internal\r\n         */\r\n        this.timeDelta = 0;\r\n        /**\r\n         * Timestamp of the last time this `MotionValue` was updated.\r\n         *\r\n         * @internal\r\n         */\r\n        this.lastUpdated = 0;\r\n        /**\r\n         * Tracks whether this value can output a velocity. Currently this is only true\r\n         * if the value is numerical, but we might be able to widen the scope here and support\r\n         * other value types.\r\n         *\r\n         * @internal\r\n         */\r\n        this.canTrackVelocity = false;\r\n        this.updateAndNotify = function (v, render) {\r\n            if (render === void 0) { render = true; }\r\n            _this.prev = _this.current;\r\n            _this.current = _this.transformer ? _this.transformer(v) : v;\r\n            if (_this.updateSubscribers && _this.prev !== _this.current) {\r\n                _this.updateSubscribers.forEach(_this.notifySubscriber);\r\n            }\r\n            if (_this.children) {\r\n                _this.children.forEach(_this.setChild);\r\n            }\r\n            if (render && _this.renderSubscribers) {\r\n                _this.renderSubscribers.forEach(_this.notifySubscriber);\r\n            }\r\n            // Update timestamp\r\n            var _a = getFrameData(), delta = _a.delta, timestamp = _a.timestamp;\r\n            if (_this.lastUpdated !== timestamp) {\r\n                _this.timeDelta = delta;\r\n                _this.lastUpdated = timestamp;\r\n                sync.postRender(_this.scheduleVelocityCheck);\r\n            }\r\n        };\r\n        /**\r\n         * Notify a subscriber with the latest value.\r\n         *\r\n         * This is an instanced and bound function to prevent generating a new\r\n         * function once per frame.\r\n         *\r\n         * @param subscriber - The subscriber to notify.\r\n         *\r\n         * @internal\r\n         */\r\n        this.notifySubscriber = function (subscriber) {\r\n            subscriber(_this.current);\r\n        };\r\n        /**\r\n         * Schedule a velocity check for the next frame.\r\n         *\r\n         * This is an instanced and bound function to prevent generating a new\r\n         * function once per frame.\r\n         *\r\n         * @internal\r\n         */\r\n        this.scheduleVelocityCheck = function () { return sync.postRender(_this.velocityCheck); };\r\n        /**\r\n         * Updates `prev` with `current` if the value hasn't been updated this frame.\r\n         * This ensures velocity calculations return `0`.\r\n         *\r\n         * This is an instanced and bound function to prevent generating a new\r\n         * function once per frame.\r\n         *\r\n         * @internal\r\n         */\r\n        this.velocityCheck = function (_a) {\r\n            var timestamp = _a.timestamp;\r\n            if (timestamp !== _this.lastUpdated) {\r\n                _this.prev = _this.current;\r\n            }\r\n        };\r\n        /**\r\n         * Updates child `MotionValue`.\r\n         *\r\n         * @param child - Child `MotionValue`.\r\n         *\r\n         * @internal\r\n         */\r\n        this.setChild = function (child) { return child.set(_this.current); };\r\n        this.parent = parent;\r\n        this.transformer = transformer;\r\n        this.set(init, false);\r\n        this.canTrackVelocity = isFloat(this.current);\r\n    }\r\n    /**\r\n     * Creates a new `MotionValue` that's subscribed to the output of this one.\r\n     *\r\n     * @param config - Optional configuration options\r\n     *\r\n     * -  `transformer`: A function to transform incoming values with.\r\n     *\r\n     * @internal\r\n     */\r\n    MotionValue.prototype.addChild = function (config) {\r\n        if (config === void 0) { config = {}; }\r\n        var child = new MotionValue(this.current, __assign({ parent: this }, config));\r\n        if (!this.children)\r\n            this.children = new Set();\r\n        this.children.add(child);\r\n        return child;\r\n    };\r\n    /**\r\n     * Stops a `MotionValue` from being subscribed to this one.\r\n     *\r\n     * @param child - The subscribed `MotionValue`\r\n     *\r\n     * @internal\r\n     */\r\n    MotionValue.prototype.removeChild = function (child) {\r\n        if (!this.children) {\r\n            return;\r\n        }\r\n        this.children.delete(child);\r\n    };\r\n    /**\r\n     * Subscribes a subscriber function to a subscription list.\r\n     *\r\n     * @param subscriptions - A `Set` of subscribers.\r\n     * @param subscription - A subscriber function.\r\n     */\r\n    MotionValue.prototype.subscribeTo = function (subscriptions, subscription) {\r\n        var _this = this;\r\n        var updateSubscriber = function () { return subscription(_this.current); };\r\n        subscriptions.add(updateSubscriber);\r\n        return function () { return subscriptions.delete(updateSubscriber); };\r\n    };\r\n    /**\r\n     * Adds a function that will be notified when the `MotionValue` is updated.\r\n     *\r\n     * It returns a function that, when called, will cancel the subscription.\r\n     *\r\n     * When calling `onChange` inside a React component, it should be wrapped with the\r\n     * `useEffect` hook. As it returns an unsubscribe function, this should be returned\r\n     * from the `useEffect` function to ensure you don't add duplicate subscribers..\r\n     *\r\n     * @library\r\n     *\r\n     * ```jsx\r\n     * function MyComponent() {\r\n     *   const x = useMotionValue(0)\r\n     *   const y = useMotionValue(0)\r\n     *   const opacity = useMotionValue(1)\r\n     *\r\n     *   useEffect(() => {\r\n     *     function updateOpacity() {\r\n     *       const maxXY = Math.max(x.get(), y.get())\r\n     *       const newOpacity = transform(maxXY, [0, 100], [1, 0])\r\n     *       opacity.set(newOpacity)\r\n     *     }\r\n     *\r\n     *     const unsubscribeX = x.onChange(updateOpacity)\r\n     *     const unsubscribeY = y.onChange(updateOpacity)\r\n     *\r\n     *     return () => {\r\n     *       unsubscribeX()\r\n     *       unsubscribeY()\r\n     *     }\r\n     *   }, [])\r\n     *\r\n     *   return <Frame x={x} />\r\n     * }\r\n     * ```\r\n     *\r\n     * @motion\r\n     *\r\n     * ```jsx\r\n     * export const MyComponent = () => {\r\n     *   const x = useMotionValue(0)\r\n     *   const y = useMotionValue(0)\r\n     *   const opacity = useMotionValue(1)\r\n     *\r\n     *   useEffect(() => {\r\n     *     function updateOpacity() {\r\n     *       const maxXY = Math.max(x.get(), y.get())\r\n     *       const newOpacity = transform(maxXY, [0, 100], [1, 0])\r\n     *       opacity.set(newOpacity)\r\n     *     }\r\n     *\r\n     *     const unsubscribeX = x.onChange(updateOpacity)\r\n     *     const unsubscribeY = y.onChange(updateOpacity)\r\n     *\r\n     *     return () => {\r\n     *       unsubscribeX()\r\n     *       unsubscribeY()\r\n     *     }\r\n     *   }, [])\r\n     *\r\n     *   return <motion.div style={{ x }} />\r\n     * }\r\n     * ```\r\n     *\r\n     * @internalremarks\r\n     *\r\n     * We could look into a `useOnChange` hook if the above lifecycle management proves confusing.\r\n     *\r\n     * ```jsx\r\n     * useOnChange(x, () => {})\r\n     * ```\r\n     *\r\n     * @param subscriber - A function that receives the latest value.\r\n     * @returns A function that, when called, will cancel this subscription.\r\n     *\r\n     * @public\r\n     */\r\n    MotionValue.prototype.onChange = function (subscription) {\r\n        if (!this.updateSubscribers)\r\n            this.updateSubscribers = new Set();\r\n        return this.subscribeTo(this.updateSubscribers, subscription);\r\n    };\r\n    /**\r\n     * Adds a function that will be notified when the `MotionValue` requests a render.\r\n     *\r\n     * @param subscriber - A function that's provided the latest value.\r\n     * @returns A function that, when called, will cancel this subscription.\r\n     *\r\n     * @internal\r\n     */\r\n    MotionValue.prototype.onRenderRequest = function (subscription) {\r\n        if (!this.renderSubscribers)\r\n            this.renderSubscribers = new Set();\r\n        // Render immediately\r\n        this.notifySubscriber(subscription);\r\n        return this.subscribeTo(this.renderSubscribers, subscription);\r\n    };\r\n    /**\r\n     * Attaches a passive effect to the `MotionValue`.\r\n     *\r\n     * @internal\r\n     */\r\n    MotionValue.prototype.attach = function (passiveEffect) {\r\n        this.passiveEffect = passiveEffect;\r\n    };\r\n    /**\r\n     * Sets the state of the `MotionValue`.\r\n     *\r\n     * @remarks\r\n     *\r\n     * ```jsx\r\n     * const x = useMotionValue(0)\r\n     * x.set(10)\r\n     * ```\r\n     *\r\n     * @param latest - Latest value to set.\r\n     * @param render - Whether to notify render subscribers. Defaults to `true`\r\n     *\r\n     * @public\r\n     */\r\n    MotionValue.prototype.set = function (v, render) {\r\n        if (render === void 0) { render = true; }\r\n        if (!render || !this.passiveEffect) {\r\n            this.updateAndNotify(v, render);\r\n        }\r\n        else {\r\n            this.passiveEffect(v, this.updateAndNotify);\r\n        }\r\n    };\r\n    /**\r\n     * Returns the latest state of `MotionValue`\r\n     *\r\n     * @returns - The latest state of `MotionValue`\r\n     *\r\n     * @public\r\n     */\r\n    MotionValue.prototype.get = function () {\r\n        return this.current;\r\n    };\r\n    /**\r\n     * Returns the latest velocity of `MotionValue`\r\n     *\r\n     * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.\r\n     *\r\n     * @public\r\n     */\r\n    MotionValue.prototype.getVelocity = function () {\r\n        // This could be isFloat(this.prev) && isFloat(this.current), but that would be wasteful\r\n        return this.canTrackVelocity\r\n            ? // These casts could be avoided if parseFloat would be typed better\r\n                velocityPerSecond(parseFloat(this.current) -\r\n                    parseFloat(this.prev), this.timeDelta)\r\n            : 0;\r\n    };\r\n    /**\r\n     * Registers a new animation to control this `MotionValue`. Only one\r\n     * animation can drive a `MotionValue` at one time.\r\n     *\r\n     * ```jsx\r\n     * value.start()\r\n     * ```\r\n     *\r\n     * @param animation - A function that starts the provided animation\r\n     *\r\n     * @internal\r\n     */\r\n    MotionValue.prototype.start = function (animation) {\r\n        var _this = this;\r\n        this.stop();\r\n        return new Promise(function (resolve) {\r\n            _this.stopAnimation = animation(resolve);\r\n        }).then(function () { return _this.clearAnimation(); });\r\n    };\r\n    /**\r\n     * Stop the currently active animation.\r\n     *\r\n     * @public\r\n     */\r\n    MotionValue.prototype.stop = function () {\r\n        if (this.stopAnimation)\r\n            this.stopAnimation();\r\n        this.clearAnimation();\r\n    };\r\n    /**\r\n     * Returns `true` if this value is currently animating.\r\n     *\r\n     * @public\r\n     */\r\n    MotionValue.prototype.isAnimating = function () {\r\n        return !!this.stopAnimation;\r\n    };\r\n    MotionValue.prototype.clearAnimation = function () {\r\n        this.stopAnimation = null;\r\n    };\r\n    /**\r\n     * Destroy and clean up subscribers to this `MotionValue`.\r\n     *\r\n     * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically\r\n     * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually\r\n     * created a `MotionValue` via the `motionValue` function.\r\n     *\r\n     * @public\r\n     */\r\n    MotionValue.prototype.destroy = function () {\r\n        this.updateSubscribers && this.updateSubscribers.clear();\r\n        this.renderSubscribers && this.renderSubscribers.clear();\r\n        this.parent && this.parent.removeChild(this);\r\n        this.stop();\r\n    };\r\n    return MotionValue;\r\n}());\r\n/**\r\n * @internal\r\n */\r\nfunction motionValue(init, opts) {\r\n    return new MotionValue(init, opts);\r\n}\n\n/**\r\n * Creates a constant value over the lifecycle of a component.\r\n *\r\n * Even if `useMemo` is provided an empty array as its final argument, it doesn't offer\r\n * a guarantee that it won't re-run for performance reasons later on. By using `useConstant`\r\n * you can ensure that initialisers don't execute twice or more.\r\n */\r\nfunction useConstant(init) {\r\n    var ref = useRef(null);\r\n    if (ref.current === null) {\r\n        ref.current = init();\r\n    }\r\n    return ref.current;\r\n}\n\nvar isMotionValue = function (value) {\r\n    return value instanceof MotionValue;\r\n};\n\n// Creating a styler factory for the `onUpdate` prop allows all values\r\n// to fire and the `onUpdate` prop will only fire once per frame\r\nvar updateStyler = createStylerFactory({\r\n    onRead: function () { return null; },\r\n    onRender: function (state, _a) {\r\n        var onUpdate = _a.onUpdate;\r\n        return onUpdate(state);\r\n    },\r\n});\r\nvar MotionValuesMap = /** @class */ (function () {\r\n    function MotionValuesMap() {\r\n        this.hasMounted = false;\r\n        this.values = new Map();\r\n        this.unsubscribers = new Map();\r\n    }\r\n    MotionValuesMap.prototype.has = function (key) {\r\n        return this.values.has(key);\r\n    };\r\n    MotionValuesMap.prototype.set = function (key, value) {\r\n        this.values.set(key, value);\r\n        if (this.hasMounted) {\r\n            this.bindValueToOutput(key, value);\r\n        }\r\n    };\r\n    MotionValuesMap.prototype.get = function (key, defaultValue) {\r\n        var value = this.values.get(key);\r\n        if (value === undefined && defaultValue !== undefined) {\r\n            value = new MotionValue(defaultValue);\r\n            this.set(key, value);\r\n        }\r\n        return value;\r\n    };\r\n    MotionValuesMap.prototype.forEach = function (callback) {\r\n        return this.values.forEach(callback);\r\n    };\r\n    MotionValuesMap.prototype.bindValueToOutput = function (key, value) {\r\n        var _this = this;\r\n        var onRender = function (v) { return _this.output && _this.output(key, v); };\r\n        var unsubscribeOnRender = value.onRenderRequest(onRender);\r\n        var onChange = function (v) {\r\n            _this.onUpdate && _this.onUpdate.set(key, v);\r\n        };\r\n        var unsubscribeOnChange = value.onChange(onChange);\r\n        if (this.unsubscribers.has(key)) {\r\n            this.unsubscribers.get(key)();\r\n        }\r\n        this.unsubscribers.set(key, function () {\r\n            unsubscribeOnRender();\r\n            unsubscribeOnChange();\r\n        });\r\n    };\r\n    MotionValuesMap.prototype.setOnUpdate = function (onUpdate) {\r\n        this.onUpdate = undefined;\r\n        if (onUpdate) {\r\n            this.onUpdate = updateStyler({ onUpdate: onUpdate });\r\n        }\r\n    };\r\n    MotionValuesMap.prototype.setTransformTemplate = function (transformTemplate) {\r\n        if (this.transformTemplate !== transformTemplate) {\r\n            this.transformTemplate = transformTemplate;\r\n            this.updateTransformTemplate();\r\n        }\r\n    };\r\n    MotionValuesMap.prototype.getTransformTemplate = function () {\r\n        return this.transformTemplate;\r\n    };\r\n    MotionValuesMap.prototype.updateTransformTemplate = function () {\r\n        if (this.output) {\r\n            this.output(\"transform\", this.transformTemplate);\r\n        }\r\n    };\r\n    MotionValuesMap.prototype.mount = function (output) {\r\n        var _this = this;\r\n        this.hasMounted = true;\r\n        if (output)\r\n            this.output = output;\r\n        this.values.forEach(function (value, key) { return _this.bindValueToOutput(key, value); });\r\n        this.updateTransformTemplate();\r\n    };\r\n    MotionValuesMap.prototype.unmount = function () {\r\n        var _this = this;\r\n        this.values.forEach(function (_value, key) {\r\n            var unsubscribe = _this.unsubscribers.get(key);\r\n            unsubscribe && unsubscribe();\r\n        });\r\n    };\r\n    return MotionValuesMap;\r\n}());\r\nvar specialMotionValueProps = new Set([\"dragOriginX\", \"dragOriginY\"]);\r\nvar useMotionValues = function (props) {\r\n    var motionValues = useConstant(function () {\r\n        var map = new MotionValuesMap();\r\n        /**\r\n         * Loop through every prop and add any detected `MotionValue`s. This is SVG-specific\r\n         * code that should be extracted, perhaps considered hollistically with `useMotionStyles`.\r\n         *\r\n         * <motion.circle cx={motionValue(0)} />\r\n         */\r\n        for (var key in props) {\r\n            if (isMotionValue(props[key]) &&\r\n                !specialMotionValueProps.has(key)) {\r\n                map.set(key, props[key]);\r\n            }\r\n        }\r\n        return map;\r\n    });\r\n    motionValues.setOnUpdate(props.onUpdate);\r\n    motionValues.setTransformTemplate(props.transformTemplate);\r\n    return motionValues;\r\n};\n\nvar session = null;\r\nvar syncRenderSession = {\r\n    isOpen: function () { return session !== null; },\r\n    open: function () {\r\n        invariant(!session, \"Sync render session already open\");\r\n        session = [];\r\n    },\r\n    flush: function () {\r\n        invariant(session !== null, \"No sync render session found\");\r\n        session && session.forEach(function (styler) { return styler.render(); });\r\n        session = null;\r\n    },\r\n    push: function (styler) {\r\n        invariant(session !== null, \"No sync render session found\");\r\n        session && session.push(styler);\r\n    },\r\n};\n\n/**\r\n * `useEffect` gets resolved bottom-up. We defer some optional functionality to child\r\n * components, so to ensure everything runs correctly we export the ref-binding logic\r\n * to a new component rather than in `useMotionValues`.\r\n */\r\nvar MountComponent = function (_a) {\r\n    var ref = _a.innerRef, values = _a.values, isStatic = _a.isStatic;\r\n    useEffect(function () {\r\n        invariant(ref.current instanceof Element, \"No `ref` found. Ensure components created with `motion.custom` forward refs using `React.forwardRef`\");\r\n        var domStyler = styler(ref.current, {\r\n            preparseOutput: false,\r\n            enableHardwareAcceleration: !isStatic,\r\n        });\r\n        values.mount(function (key, value) {\r\n            domStyler.set(key, value);\r\n            if (syncRenderSession.isOpen()) {\r\n                syncRenderSession.push(domStyler);\r\n            }\r\n        });\r\n        return function () { return values.unmount(); };\r\n    }, []);\r\n    return null;\r\n};\r\nvar Mount = memo(MountComponent);\n\nvar createValueResolver = function (resolver) { return function (values) {\r\n    var resolvedValues = {};\r\n    values.forEach(function (value, key) { return (resolvedValues[key] = resolver(value)); });\r\n    return resolvedValues;\r\n}; };\r\nvar resolveCurrent = createValueResolver(function (value) { return value.get(); });\n\nvar transformOriginProps = new Set([\"originX\", \"originY\", \"originZ\"]);\r\nvar isTransformOriginProp = function (key) { return transformOriginProps.has(key); };\r\nvar buildStyleAttr = function (values, styleProp, isStatic) {\r\n    var motionValueStyles = resolveCurrent(values);\r\n    var transformTemplate = values.getTransformTemplate();\r\n    if (transformTemplate) {\r\n        // If `transform` has been manually set as a string, pass that through the template\r\n        // otherwise pass it forward to Stylefire's style property builder\r\n        motionValueStyles.transform = styleProp.transform\r\n            ? transformTemplate({}, styleProp.transform)\r\n            : transformTemplate;\r\n    }\r\n    return buildStyleProperty(__assign(__assign({}, styleProp), motionValueStyles), !isStatic);\r\n};\r\nvar useMotionStyles = function (values, styleProp, isStatic, transformValues) {\r\n    if (styleProp === void 0) { styleProp = {}; }\r\n    var style = {};\r\n    var prevMotionStyles = useRef({}).current;\r\n    for (var key in styleProp) {\r\n        var thisStyle = styleProp[key];\r\n        if (isMotionValue(thisStyle)) {\r\n            // If this is a motion value, add it to our MotionValuesMap\r\n            values.set(key, thisStyle);\r\n        }\r\n        else if (!isStatic &&\r\n            (isTransformProp(key) || isTransformOriginProp(key))) {\r\n            // Or if it's a transform prop, create a motion value (or update an existing one)\r\n            // to ensure Stylefire can reconcile all the transform values together.\r\n            // A further iteration on this would be to create a single styler per component that gets\r\n            // used in the DOM renderer's buildStyleAttr *and* animations, then we would only\r\n            // have to convert animating values to `MotionValues` (we could probably remove this entire function).\r\n            // The only architectural consideration is to allow Stylefire to have elements mounted after\r\n            // a styler is created.\r\n            if (!values.has(key)) {\r\n                // If it doesn't exist as a motion value, create it\r\n                values.set(key, motionValue(thisStyle));\r\n            }\r\n            else {\r\n                // Otherwise only update it if it's changed from a previous render\r\n                if (thisStyle !== prevMotionStyles[key]) {\r\n                    var value = values.get(key);\r\n                    value.set(thisStyle);\r\n                }\r\n            }\r\n            prevMotionStyles[key] = thisStyle;\r\n        }\r\n        else {\r\n            style[key] = thisStyle;\r\n        }\r\n    }\r\n    return transformValues ? transformValues(style) : style;\r\n};\n\nvar isKeyframesTarget = function (v) {\r\n    return Array.isArray(v);\r\n};\n\nvar isCustomValue = function (v) {\r\n    return Boolean(v && typeof v === \"object\" && v.mix && v.toValue);\r\n};\r\nvar resolveFinalValueInKeyframes = function (v) {\r\n    // TODO maybe throw if v.length - 1 is placeholder token?\r\n    return isKeyframesTarget(v) ? v[v.length - 1] || 0 : v;\r\n};\n\nvar auto = {\r\n    test: function (v) { return v === \"auto\"; },\r\n    parse: function (v) { return v; },\r\n};\r\nvar dimensionTypes = [number, px, percent, degrees, vw, vh, auto];\r\nvar valueTypes = __spreadArrays(dimensionTypes, [color, complex]);\r\nvar testValueType = function (v) { return function (type) { return type.test(v); }; };\r\nvar getDimensionValueType = function (v) {\r\n    return dimensionTypes.find(testValueType(v));\r\n};\r\nvar getValueType = function (v) { return valueTypes.find(testValueType(v)); };\n\nvar underDampedSpring = function () { return ({\r\n    type: \"spring\",\r\n    stiffness: 500,\r\n    damping: 25,\r\n    restDelta: 0.5,\r\n    restSpeed: 10,\r\n}); };\r\nvar overDampedSpring = function (to) { return ({\r\n    type: \"spring\",\r\n    stiffness: 700,\r\n    damping: to === 0 ? 100 : 35,\r\n}); };\r\nvar linearTween = function () { return ({\r\n    ease: \"linear\",\r\n    duration: 0.3,\r\n}); };\r\nvar keyframes = function (values) { return ({\r\n    type: \"keyframes\",\r\n    duration: 0.8,\r\n    values: values,\r\n}); };\r\nvar defaultTransitions = {\r\n    x: underDampedSpring,\r\n    y: underDampedSpring,\r\n    z: underDampedSpring,\r\n    rotate: underDampedSpring,\r\n    rotateX: underDampedSpring,\r\n    rotateY: underDampedSpring,\r\n    rotateZ: underDampedSpring,\r\n    scaleX: overDampedSpring,\r\n    scaleY: overDampedSpring,\r\n    scale: overDampedSpring,\r\n    opacity: linearTween,\r\n    backgroundColor: linearTween,\r\n    color: linearTween,\r\n    default: overDampedSpring,\r\n};\r\nvar getDefaultTransition = function (valueKey, to) {\r\n    var transitionFactory;\r\n    if (isKeyframesTarget(to)) {\r\n        transitionFactory = keyframes;\r\n    }\r\n    else {\r\n        transitionFactory =\r\n            defaultTransitions[valueKey] || defaultTransitions.default;\r\n    }\r\n    return __assign({ to: to }, transitionFactory(to));\r\n};\n\n/**\r\n * A Popmotion action that accepts a single `to` prop. When it starts, it immediately\r\n * updates with `to` and then completes. By using this we can compose instant transitions\r\n * in with the same logic that applies `delay` or returns a `Promise` etc.\r\n *\r\n * Accepting `duration` is a little bit of a hack that simply defers the completetion of\r\n * the animation until after the duration finishes. This is for situations when you're **only**\r\n * animating non-animatable values and then setting something on `transitionEnd`. Really\r\n * you want this to fire after the \"animation\" finishes, rather than instantly.\r\n *\r\n * ```\r\n * animate={{\r\n *   display: 'block',\r\n *   transitionEnd: { display: 'none' }\r\n * }}\r\n * ```\r\n */\r\nvar just = function (_a) {\r\n    var to = _a.to, duration = _a.duration;\r\n    return action(function (_a) {\r\n        var update = _a.update, complete = _a.complete;\r\n        update(to);\r\n        duration ? delay(duration).start({ complete: complete }) : complete();\r\n    });\r\n};\n\nvar easingDefinitionToFunction = function (definition) {\r\n    if (Array.isArray(definition)) {\r\n        // If cubic bezier definition, create bezier curve\r\n        invariant(definition.length === 4, \"Cubic bezier arrays must contain four numerical values.\");\r\n        var x1 = definition[0], y1 = definition[1], x2 = definition[2], y2 = definition[3];\r\n        return cubicBezier(x1, y1, x2, y2);\r\n    }\r\n    else if (typeof definition === \"string\") {\r\n        // Else lookup from table\r\n        invariant(easingLookup[definition] !== undefined, \"Invalid easing type '\" + definition + \"'\");\r\n        return easingLookup[definition];\r\n    }\r\n    return definition;\r\n};\r\nvar isEasingArray = function (ease) {\r\n    return Array.isArray(ease) && typeof ease[0] !== \"number\";\r\n};\n\nvar isDurationAnimation = function (v) {\r\n    return v.hasOwnProperty(\"duration\") || v.hasOwnProperty(\"repeatDelay\");\r\n};\n\n/**\r\n * Check if a value is animatable. Examples:\r\n *\r\n * ✅: 100, \"100px\", \"#fff\"\r\n * ❌: \"block\", \"url(2.jpg)\"\r\n * @param value\r\n *\r\n * @internal\r\n */\r\nvar isAnimatable = function (key, value) {\r\n    // If the list of keys tat might be non-animatable grows, replace with Set\r\n    if (key === \"zIndex\")\r\n        return false;\r\n    // If it's a number or a keyframes array, we can animate it. We might at some point\r\n    // need to do a deep isAnimatable check of keyframes, or let Popmotion handle this,\r\n    // but for now lets leave it like this for performance reasons\r\n    if (typeof value === \"number\" || Array.isArray(value))\r\n        return true;\r\n    if (typeof value === \"string\" && // It's animatable if we have a string\r\n        complex.test(value) && // And it contains numbers and/or colors\r\n        !value.startsWith(\"url(\") // Unless it starts with \"url(\"\r\n    ) {\r\n        return true;\r\n    }\r\n    return false;\r\n};\n\n/**\r\n * Converts seconds to milliseconds\r\n *\r\n * @param seconds - Time in seconds.\r\n * @return milliseconds - Converted time in milliseconds.\r\n */\r\nvar secondsToMilliseconds = function (seconds) { return seconds * 1000; };\n\nvar transitions = { tween: tween, spring: spring, keyframes: keyframes$1, inertia: inertia, just: just };\r\nvar transitionOptionParser = {\r\n    tween: function (opts) {\r\n        if (opts.ease) {\r\n            var ease = isEasingArray(opts.ease) ? opts.ease[0] : opts.ease;\r\n            opts.ease = easingDefinitionToFunction(ease);\r\n        }\r\n        return opts;\r\n    },\r\n    keyframes: function (_a) {\r\n        var from = _a.from, to = _a.to, velocity = _a.velocity, opts = __rest(_a, [\"from\", \"to\", \"velocity\"]);\r\n        if (opts.values && opts.values[0] === null) {\r\n            var values = __spreadArrays(opts.values);\r\n            values[0] = from;\r\n            opts.values = values;\r\n        }\r\n        if (opts.ease) {\r\n            opts.easings = isEasingArray(opts.ease)\r\n                ? opts.ease.map(easingDefinitionToFunction)\r\n                : easingDefinitionToFunction(opts.ease);\r\n        }\r\n        opts.ease = linear;\r\n        return opts;\r\n    },\r\n};\r\nvar isTransitionDefined = function (_a) {\r\n    var when = _a.when, delay = _a.delay, delayChildren = _a.delayChildren, staggerChildren = _a.staggerChildren, staggerDirection = _a.staggerDirection, transition = __rest(_a, [\"when\", \"delay\", \"delayChildren\", \"staggerChildren\", \"staggerDirection\"]);\r\n    return Object.keys(transition).length;\r\n};\r\nvar getTransitionDefinition = function (key, to, transitionDefinition) {\r\n    var delay = transitionDefinition ? transitionDefinition.delay : 0;\r\n    // If no object, return default transition\r\n    // A better way to handle this would be to deconstruct out all the shared Orchestration props\r\n    // and see if there's any props remaining\r\n    if (transitionDefinition === undefined ||\r\n        !isTransitionDefined(transitionDefinition)) {\r\n        return __assign({ delay: delay }, getDefaultTransition(key, to));\r\n    }\r\n    var valueTransitionDefinition = transitionDefinition[key] ||\r\n        transitionDefinition.default ||\r\n        transitionDefinition;\r\n    if (valueTransitionDefinition.type === false) {\r\n        return {\r\n            delay: valueTransitionDefinition.hasOwnProperty(\"delay\")\r\n                ? valueTransitionDefinition.delay\r\n                : delay,\r\n            to: isKeyframesTarget(to)\r\n                ? to[to.length - 1]\r\n                : to,\r\n            type: \"just\",\r\n        };\r\n    }\r\n    else if (isKeyframesTarget(to)) {\r\n        return __assign(__assign({ values: to, duration: 0.8, delay: delay, ease: \"linear\" }, valueTransitionDefinition), { \r\n            // This animation must be keyframes if we're animating through an array\r\n            type: \"keyframes\" });\r\n    }\r\n    else {\r\n        return __assign({ type: \"tween\", to: to,\r\n            delay: delay }, valueTransitionDefinition);\r\n    }\r\n};\r\nvar preprocessOptions = function (type, opts) {\r\n    return transitionOptionParser[type]\r\n        ? transitionOptionParser[type](opts)\r\n        : opts;\r\n};\r\nvar getAnimation = function (key, value, target, transition) {\r\n    var origin = value.get();\r\n    var isOriginAnimatable = isAnimatable(key, origin);\r\n    var isTargetAnimatable = isAnimatable(key, target);\r\n    // TODO we could probably improve this check to ensure both values are of the same type -\r\n    // for instance 100 to #fff. This might live better in Popmotion.\r\n    warning(isOriginAnimatable === isTargetAnimatable, \"You are trying to animate \" + key + \" from \\\"\" + origin + \"\\\" to \" + target + \". \\\"\" + origin + \"\\\" is not an animatable value - to enable this animation set \" + origin + \" to a value animatable to \" + target + \" via the `style` property.\");\r\n    // Parse the `transition` prop and return options for the Popmotion animation\r\n    var _a = getTransitionDefinition(key, target, transition), _b = _a.type, type = _b === void 0 ? \"tween\" : _b, transitionDefinition = __rest(_a, [\"type\"]);\r\n    // If this is an animatable pair of values, return an animation, otherwise use `just`\r\n    var actionFactory = isOriginAnimatable && isTargetAnimatable\r\n        ? transitions[type]\r\n        : just;\r\n    var opts = preprocessOptions(type, __assign({ from: origin, velocity: value.getVelocity() }, transitionDefinition));\r\n    // Convert duration from Framer Motion's seconds into Popmotion's milliseconds\r\n    if (isDurationAnimation(opts)) {\r\n        if (opts.duration) {\r\n            opts.duration = secondsToMilliseconds(opts.duration);\r\n        }\r\n        if (opts.repeatDelay) {\r\n            opts.repeatDelay = secondsToMilliseconds(opts.repeatDelay);\r\n        }\r\n    }\r\n    return [actionFactory, opts];\r\n};\r\n/**\r\n * Start animation on a value. This function completely encapsulates Popmotion-specific logic.\r\n *\r\n * @internal\r\n */\r\nfunction startAnimation(key, value, target, _a) {\r\n    var _b = _a.delay, delay$1 = _b === void 0 ? 0 : _b, transition = __rest(_a, [\"delay\"]);\r\n    return value.start(function (complete) {\r\n        var activeAnimation;\r\n        var _a = getAnimation(key, value, target, transition), animationFactory = _a[0], _b = _a[1], valueDelay = _b.delay, options = __rest(_b, [\"delay\"]);\r\n        if (valueDelay !== undefined) {\r\n            delay$1 = valueDelay;\r\n        }\r\n        var animate = function () {\r\n            var animation = animationFactory(options);\r\n            // Bind animation opts to animation\r\n            activeAnimation = animation.start({\r\n                update: function (v) { return value.set(v); },\r\n                complete: complete,\r\n            });\r\n        };\r\n        // If we're delaying this animation, only resolve it **after** the delay to\r\n        // ensure the value's resolve velocity is up-to-date.\r\n        if (delay$1) {\r\n            activeAnimation = delay(secondsToMilliseconds(delay$1)).start({\r\n                complete: animate,\r\n            });\r\n        }\r\n        else {\r\n            animate();\r\n        }\r\n        return function () {\r\n            if (activeAnimation)\r\n                activeAnimation.stop();\r\n        };\r\n    });\r\n}\n\n/**\r\n * Get the current value of every `MotionValue`\r\n * @param values -\r\n */\r\nvar getCurrent = function (values) {\r\n    var current = {};\r\n    values.forEach(function (value, key) { return (current[key] = value.get()); });\r\n    return current;\r\n};\r\n/**\r\n * Get the current velocity of every `MotionValue`\r\n * @param values -\r\n */\r\nvar getVelocity = function (values) {\r\n    var velocity = {};\r\n    values.forEach(function (value, key) { return (velocity[key] = value.getVelocity()); });\r\n    return velocity;\r\n};\r\n/**\r\n * Check if value is a function that returns a `Target`. A generic typeof === 'function'\r\n * check, just helps with typing.\r\n * @param p -\r\n */\r\nvar isTargetResolver = function (p) {\r\n    return typeof p === \"function\";\r\n};\r\n/**\r\n * Check if value is a list of variant labels\r\n * @param v -\r\n */\r\nvar isVariantLabels = function (v) { return Array.isArray(v); };\r\n/**\r\n * Check if value is a numerical string, ie \"100\" or \"100px\"\r\n */\r\nvar isNumericalString = function (v) { return /^\\d*\\.?\\d+$/.test(v); };\r\n/**\r\n * Control animations for a single component\r\n *\r\n * @internal\r\n */\r\nvar ValueAnimationControls = /** @class */ (function () {\r\n    function ValueAnimationControls(_a) {\r\n        var _this = this;\r\n        var values = _a.values, readValueFromSource = _a.readValueFromSource, makeTargetAnimatable = _a.makeTargetAnimatable;\r\n        /**\r\n         * A reference to the component's latest props. We could probably ditch this in\r\n         * favour to a reference to the `custom` prop now we don't send all props through\r\n         * to target resolvers.\r\n         */\r\n        this.props = {};\r\n        /**\r\n         * The component's variants, as provided by `variants`\r\n         */\r\n        this.variants = {};\r\n        /**\r\n         * A set of values that we animate back to when a value is cleared of all overrides.\r\n         */\r\n        this.baseTarget = {};\r\n        /**\r\n         * A series of target overrides that we can animate to/from when overrides are set/cleared.\r\n         */\r\n        this.overrides = [];\r\n        /**\r\n         * A series of target overrides as they were originally resolved.\r\n         */\r\n        this.resolvedOverrides = [];\r\n        /**\r\n         * A Set of currently active override indexes\r\n         */\r\n        this.activeOverrides = new Set();\r\n        /**\r\n         * A Set of value keys that are currently animating.\r\n         */\r\n        this.isAnimating = new Set();\r\n        /**\r\n         * Check if the associated `MotionValueMap` has a key with the provided string.\r\n         * Pre-bound to the class so we can provide directly to the `filter` in `checkForNewValues`.\r\n         */\r\n        this.hasValue = function (key) { return !_this.values.has(key); };\r\n        this.values = values;\r\n        this.readValueFromSource = readValueFromSource;\r\n        this.makeTargetAnimatable = makeTargetAnimatable;\r\n        this.values.forEach(function (value, key) { return (_this.baseTarget[key] = value.get()); });\r\n    }\r\n    /**\r\n     * Set the reference to the component's props.\r\n     * @param props -\r\n     */\r\n    ValueAnimationControls.prototype.setProps = function (props) {\r\n        this.props = props;\r\n    };\r\n    /**\r\n     * Set the reference to the component's variants\r\n     * @param variants -\r\n     */\r\n    ValueAnimationControls.prototype.setVariants = function (variants) {\r\n        if (variants)\r\n            this.variants = variants;\r\n    };\r\n    /**\r\n     * Set the component's default transition\r\n     * @param transition -\r\n     */\r\n    ValueAnimationControls.prototype.setDefaultTransition = function (transition) {\r\n        if (transition)\r\n            this.defaultTransition = transition;\r\n    };\r\n    /**\r\n     * Set motion values without animation.\r\n     *\r\n     * @param definition -\r\n     * @param isActive -\r\n     */\r\n    ValueAnimationControls.prototype.setValues = function (definition, _a) {\r\n        var _this = this;\r\n        var _b = _a === void 0 ? {} : _a, _c = _b.isActive, isActive = _c === void 0 ? new Set() : _c, priority = _b.priority;\r\n        var _d = this.resolveVariant(definition), target = _d.target, transitionEnd = _d.transitionEnd;\r\n        target = this.transformValues(__assign(__assign({}, target), transitionEnd));\r\n        return Object.keys(target).forEach(function (key) {\r\n            if (isActive.has(key))\r\n                return;\r\n            isActive.add(key);\r\n            if (target) {\r\n                var targetValue = resolveFinalValueInKeyframes(target[key]);\r\n                if (_this.values.has(key)) {\r\n                    var value = _this.values.get(key);\r\n                    value && value.set(targetValue);\r\n                }\r\n                else {\r\n                    _this.values.set(key, motionValue(targetValue));\r\n                }\r\n                if (!priority)\r\n                    _this.baseTarget[key] = targetValue;\r\n            }\r\n        });\r\n    };\r\n    /**\r\n     * Allows `transformValues` to be set by a component that allows us to\r\n     * transform the values in a given `Target`. This allows Framer Library\r\n     * to extend Framer Motion to animate `Color` variables etc. Currently we have\r\n     * to manually support these extended types here in Framer Motion.\r\n     *\r\n     * @param values -\r\n     */\r\n    ValueAnimationControls.prototype.transformValues = function (values) {\r\n        var transformValues = this.props.transformValues;\r\n        return transformValues ? transformValues(values) : values;\r\n    };\r\n    /**\r\n     * Check a `Target` for new values we haven't animated yet, and add them\r\n     * to the `MotionValueMap`.\r\n     *\r\n     * Currently there's functionality here that is DOM-specific, we should allow\r\n     * this functionality to be injected by the factory that creates DOM-specific\r\n     * components.\r\n     *\r\n     * @param target -\r\n     */\r\n    ValueAnimationControls.prototype.checkForNewValues = function (target) {\r\n        var newValueKeys = Object.keys(target).filter(this.hasValue);\r\n        var numNewValues = newValueKeys.length;\r\n        if (!numNewValues)\r\n            return;\r\n        for (var i = 0; i < numNewValues; i++) {\r\n            var key = newValueKeys[i];\r\n            var targetValue = target[key];\r\n            var value = null;\r\n            // If this is a keyframes value, we can attempt to use the first value in the\r\n            // array as that's going to be the first value of the animation anyway\r\n            if (Array.isArray(targetValue)) {\r\n                value = targetValue[0];\r\n            }\r\n            // If it isn't a keyframes or the first keyframes value was set as `null`, read the\r\n            // value from the DOM. It might be worth investigating whether to check props (for SVG)\r\n            // or props.style (for HTML) if the value exists there before attempting to read.\r\n            if (value === null) {\r\n                value = this.readValueFromSource(key);\r\n                invariant(value !== null, \"No initial value for \\\"\" + key + \"\\\" can be inferred. Ensure an initial value for \\\"\" + key + \"\\\" is defined on the component.\");\r\n            }\r\n            if (typeof value === \"string\" && isNumericalString(value)) {\r\n                // If this is a number read as a string, ie \"0\" or \"200\", convert it to a number\r\n                value = parseFloat(value);\r\n            }\r\n            else if (!getValueType(value) && complex.test(targetValue)) {\r\n                // If value is not recognised as animatable, ie \"none\", create an animatable version origin based on the target\r\n                value = complex.getAnimatableNone(targetValue);\r\n            }\r\n            this.values.set(key, motionValue(value));\r\n            this.baseTarget[key] = value;\r\n        }\r\n    };\r\n    /**\r\n     * Resolve a variant from its label or resolver into an actual `Target` we can animate to.\r\n     * @param variant -\r\n     */\r\n    ValueAnimationControls.prototype.resolveVariant = function (variant) {\r\n        if (!variant) {\r\n            return {\r\n                target: undefined,\r\n                transition: undefined,\r\n                transitionEnd: undefined,\r\n            };\r\n        }\r\n        if (isTargetResolver(variant)) {\r\n            // resolve current and velocity\r\n            variant = variant(this.props.custom, getCurrent(this.values), getVelocity(this.values));\r\n        }\r\n        var _a = variant.transition, transition = _a === void 0 ? this.defaultTransition : _a, transitionEnd = variant.transitionEnd, target = __rest(variant, [\"transition\", \"transitionEnd\"]);\r\n        return { transition: transition, transitionEnd: transitionEnd, target: target };\r\n    };\r\n    /**\r\n     * Get the highest active override priority index\r\n     */\r\n    ValueAnimationControls.prototype.getHighestPriority = function () {\r\n        if (!this.activeOverrides.size)\r\n            return 0;\r\n        return Math.max.apply(Math, Array.from(this.activeOverrides));\r\n    };\r\n    /**\r\n     * Set an override. We add this layer of indirection so if, for instance, a tap gesture\r\n     * starts and overrides a hover gesture, when we clear the tap gesture and fallback to the\r\n     * hover gesture, if that hover gesture has changed in the meantime we can go to that rather\r\n     * than the one that was resolved when the hover gesture animation started.\r\n     *\r\n     * @param definition -\r\n     * @param overrideIndex -\r\n     */\r\n    ValueAnimationControls.prototype.setOverride = function (definition, overrideIndex) {\r\n        this.overrides[overrideIndex] = definition;\r\n        if (this.children) {\r\n            this.children.forEach(function (child) {\r\n                return child.setOverride(definition, overrideIndex);\r\n            });\r\n        }\r\n    };\r\n    /**\r\n     * Start an override animation.\r\n     * @param overrideIndex -\r\n     */\r\n    ValueAnimationControls.prototype.startOverride = function (overrideIndex) {\r\n        var override = this.overrides[overrideIndex];\r\n        if (override) {\r\n            return this.start(override, { priority: overrideIndex });\r\n        }\r\n    };\r\n    /**\r\n     * Clear an override. We check every value we animated to in this override to see if\r\n     * its present on any lower-priority overrides. If not, we animate it back to its base target.\r\n     * @param overrideIndex -\r\n     */\r\n    ValueAnimationControls.prototype.clearOverride = function (overrideIndex) {\r\n        var _this = this;\r\n        if (this.children) {\r\n            this.children.forEach(function (child) { return child.clearOverride(overrideIndex); });\r\n        }\r\n        var override = this.overrides[overrideIndex];\r\n        if (!override)\r\n            return;\r\n        this.activeOverrides.delete(overrideIndex);\r\n        var highest = this.getHighestPriority();\r\n        this.resetIsAnimating();\r\n        if (highest) {\r\n            var highestOverride = this.overrides[highest];\r\n            highestOverride && this.startOverride(highest);\r\n        }\r\n        // Figure out which remaining values were affected by the override and animate those\r\n        var overrideTarget = this.resolvedOverrides[overrideIndex];\r\n        if (!overrideTarget)\r\n            return;\r\n        var remainingValues = {};\r\n        for (var key in this.baseTarget) {\r\n            if (overrideTarget[key] !== undefined) {\r\n                remainingValues[key] = this.baseTarget[key];\r\n            }\r\n        }\r\n        this.onStart();\r\n        this.animate(remainingValues).then(function () { return _this.onComplete(); });\r\n    };\r\n    /**\r\n     * Apply a target/variant without any animation\r\n     */\r\n    ValueAnimationControls.prototype.apply = function (definition) {\r\n        if (Array.isArray(definition)) {\r\n            return this.applyVariantLabels(definition);\r\n        }\r\n        else if (typeof definition === \"string\") {\r\n            return this.applyVariantLabels([definition]);\r\n        }\r\n        else {\r\n            this.setValues(definition);\r\n        }\r\n    };\r\n    /**\r\n     * Apply variant labels without animation\r\n     */\r\n    ValueAnimationControls.prototype.applyVariantLabels = function (variantLabelList) {\r\n        var _this = this;\r\n        var isActive = new Set();\r\n        var reversedList = __spreadArrays(variantLabelList).reverse();\r\n        reversedList.forEach(function (key) {\r\n            var _a = _this.resolveVariant(_this.variants[key]), target = _a.target, transitionEnd = _a.transitionEnd;\r\n            if (transitionEnd) {\r\n                _this.setValues(transitionEnd, { isActive: isActive });\r\n            }\r\n            if (target) {\r\n                _this.setValues(target, { isActive: isActive });\r\n            }\r\n            if (_this.children && _this.children.size) {\r\n                _this.children.forEach(function (child) {\r\n                    return child.applyVariantLabels(variantLabelList);\r\n                });\r\n            }\r\n        });\r\n    };\r\n    ValueAnimationControls.prototype.start = function (definition, opts) {\r\n        var _this = this;\r\n        if (opts === void 0) { opts = {}; }\r\n        if (opts.priority) {\r\n            this.activeOverrides.add(opts.priority);\r\n        }\r\n        this.resetIsAnimating(opts.priority);\r\n        var animation;\r\n        if (isVariantLabels(definition)) {\r\n            animation = this.animateVariantLabels(definition, opts);\r\n        }\r\n        else if (typeof definition === \"string\") {\r\n            animation = this.animateVariant(definition, opts);\r\n        }\r\n        else {\r\n            animation = this.animate(definition, opts);\r\n        }\r\n        this.onStart();\r\n        return animation.then(function () { return _this.onComplete(); });\r\n    };\r\n    ValueAnimationControls.prototype.animate = function (animationDefinition, _a) {\r\n        var _this = this;\r\n        var _b = _a === void 0 ? {} : _a, _c = _b.delay, delay = _c === void 0 ? 0 : _c, _d = _b.priority, priority = _d === void 0 ? 0 : _d, transitionOverride = _b.transitionOverride;\r\n        var _e = this.resolveVariant(animationDefinition), target = _e.target, transition = _e.transition, transitionEnd = _e.transitionEnd;\r\n        if (transitionOverride) {\r\n            transition = transitionOverride;\r\n        }\r\n        if (!target)\r\n            return Promise.resolve();\r\n        target = this.transformValues(target);\r\n        if (transitionEnd) {\r\n            transitionEnd = this.transformValues(transitionEnd);\r\n        }\r\n        this.checkForNewValues(target);\r\n        if (this.makeTargetAnimatable) {\r\n            var animatable = this.makeTargetAnimatable(target, transitionEnd);\r\n            target = animatable.target;\r\n            transitionEnd = animatable.transitionEnd;\r\n        }\r\n        if (priority) {\r\n            this.resolvedOverrides[priority] = target;\r\n        }\r\n        this.checkForNewValues(target);\r\n        var animations = [];\r\n        for (var key in target) {\r\n            var value = this.values.get(key);\r\n            if (!value || !target || target[key] === undefined)\r\n                continue;\r\n            var valueTarget = target[key];\r\n            if (!priority) {\r\n                this.baseTarget[key] = resolveFinalValueInKeyframes(valueTarget);\r\n            }\r\n            if (this.isAnimating.has(key))\r\n                continue;\r\n            this.isAnimating.add(key);\r\n            animations.push(startAnimation(key, value, valueTarget, __assign({ delay: delay }, transition)));\r\n        }\r\n        var allAnimations = Promise.all(animations);\r\n        return transitionEnd\r\n            ? allAnimations.then(function () {\r\n                _this.setValues(transitionEnd, { priority: priority });\r\n            })\r\n            : allAnimations;\r\n    };\r\n    ValueAnimationControls.prototype.animateVariantLabels = function (variantLabels, opts) {\r\n        var _this = this;\r\n        var animations = __spreadArrays(variantLabels).reverse()\r\n            .map(function (label) { return _this.animateVariant(label, opts); });\r\n        return Promise.all(animations);\r\n    };\r\n    ValueAnimationControls.prototype.animateVariant = function (variantLabel, opts) {\r\n        var _this = this;\r\n        var when = false;\r\n        var delayChildren = 0;\r\n        var staggerChildren = 0;\r\n        var staggerDirection = 1;\r\n        var priority = (opts && opts.priority) || 0;\r\n        var variant = this.variants[variantLabel];\r\n        var getAnimations = variant\r\n            ? function () { return _this.animate(variant, opts); }\r\n            : function () { return Promise.resolve(); };\r\n        var getChildrenAnimations = this.children\r\n            ? function () {\r\n                return _this.animateChildren(variantLabel, delayChildren, staggerChildren, staggerDirection, priority);\r\n            }\r\n            : function () { return Promise.resolve(); };\r\n        if (variant && this.children) {\r\n            var transition = this.resolveVariant(variant).transition;\r\n            if (transition) {\r\n                when = transition.when || when;\r\n                delayChildren = transition.delayChildren || delayChildren;\r\n                staggerChildren = transition.staggerChildren || staggerChildren;\r\n                staggerDirection =\r\n                    transition.staggerDirection || staggerDirection;\r\n            }\r\n        }\r\n        if (when) {\r\n            var _a = when === \"beforeChildren\"\r\n                ? [getAnimations, getChildrenAnimations]\r\n                : [getChildrenAnimations, getAnimations], first = _a[0], last = _a[1];\r\n            return first().then(last);\r\n        }\r\n        else {\r\n            return Promise.all([getAnimations(), getChildrenAnimations()]);\r\n        }\r\n    };\r\n    ValueAnimationControls.prototype.animateChildren = function (variantLabel, delayChildren, staggerChildren, staggerDirection, priority) {\r\n        if (delayChildren === void 0) { delayChildren = 0; }\r\n        if (staggerChildren === void 0) { staggerChildren = 0; }\r\n        if (staggerDirection === void 0) { staggerDirection = 1; }\r\n        if (priority === void 0) { priority = 0; }\r\n        if (!this.children) {\r\n            return Promise.resolve();\r\n        }\r\n        var animations = [];\r\n        var maxStaggerDuration = (this.children.size - 1) * staggerChildren;\r\n        var generateStaggerDuration = staggerDirection === 1\r\n            ? function (i) { return i * staggerChildren; }\r\n            : function (i) { return maxStaggerDuration - i * staggerChildren; };\r\n        Array.from(this.children).forEach(function (childControls, i) {\r\n            var animation = childControls.animateVariant(variantLabel, {\r\n                priority: priority,\r\n                delay: delayChildren + generateStaggerDuration(i),\r\n            });\r\n            animations.push(animation);\r\n        });\r\n        return Promise.all(animations);\r\n    };\r\n    ValueAnimationControls.prototype.onStart = function () {\r\n        var onAnimationStart = this.props.onAnimationStart;\r\n        onAnimationStart && onAnimationStart();\r\n    };\r\n    ValueAnimationControls.prototype.onComplete = function () {\r\n        var onAnimationComplete = this.props.onAnimationComplete;\r\n        onAnimationComplete && onAnimationComplete();\r\n    };\r\n    ValueAnimationControls.prototype.checkOverrideIsAnimating = function (priority) {\r\n        var numOverrides = this.overrides.length;\r\n        for (var i = priority + 1; i < numOverrides; i++) {\r\n            var resolvedOverride = this.resolvedOverrides[i];\r\n            if (resolvedOverride) {\r\n                for (var key in resolvedOverride) {\r\n                    this.isAnimating.add(key);\r\n                }\r\n            }\r\n        }\r\n    };\r\n    ValueAnimationControls.prototype.resetIsAnimating = function (priority) {\r\n        if (priority === void 0) { priority = 0; }\r\n        this.isAnimating.clear();\r\n        // If this isn't the highest priority gesture, block the animation\r\n        // of anything that's currently being animated\r\n        if (priority < this.getHighestPriority()) {\r\n            this.checkOverrideIsAnimating(priority);\r\n        }\r\n        if (this.children) {\r\n            this.children.forEach(function (child) { return child.resetIsAnimating(priority); });\r\n        }\r\n    };\r\n    ValueAnimationControls.prototype.stop = function () {\r\n        this.values.forEach(function (value) { return value.stop(); });\r\n    };\r\n    /**\r\n     * Add the controls of a child component.\r\n     * @param controls -\r\n     */\r\n    ValueAnimationControls.prototype.addChild = function (controls) {\r\n        if (!this.children) {\r\n            this.children = new Set();\r\n        }\r\n        this.children.add(controls);\r\n        // We set child overrides when `setOverride` is called, but also have to do it here\r\n        // as the first time `setOverride` is called all the children might not have been added yet.\r\n        this.overrides.forEach(function (override, i) {\r\n            override && controls.setOverride(override, i);\r\n        });\r\n    };\r\n    ValueAnimationControls.prototype.removeChild = function (controls) {\r\n        if (!this.children) {\r\n            return;\r\n        }\r\n        this.children.delete(controls);\r\n    };\r\n    ValueAnimationControls.prototype.resetChildren = function () {\r\n        if (this.children)\r\n            this.children.clear();\r\n    };\r\n    return ValueAnimationControls;\r\n}());\n\n/**\r\n * Use callback either only on the initial render or on all renders. In concurrent mode\r\n * the \"initial\" render might run multiple times\r\n *\r\n * @param callback - Callback to run\r\n * @param isInitialOnly - Set to `true` to only run on initial render, or `false` for all renders. Defaults to `false`.\r\n *\r\n * @public\r\n */\r\nfunction useInitialOrEveryRender(callback, isInitialOnly) {\r\n    if (isInitialOnly === void 0) { isInitialOnly = false; }\r\n    var isInitialRender = useRef(true);\r\n    if (!isInitialOnly || (isInitialOnly && isInitialRender.current)) {\r\n        callback();\r\n    }\r\n    isInitialRender.current = false;\r\n}\n\n/**\r\n * Control animations on one or more components.\r\n *\r\n * @public\r\n */\r\nvar AnimationControls = /** @class */ (function () {\r\n    function AnimationControls() {\r\n        /**\r\n         * Track whether the host component has mounted.\r\n         *\r\n         * @internal\r\n         */\r\n        this.hasMounted = false;\r\n        /**\r\n         * Pending animations that are started before a component is mounted.\r\n         *\r\n         * @internal\r\n         */\r\n        this.pendingAnimations = [];\r\n        /**\r\n         * A collection of linked component animation controls.\r\n         *\r\n         * @internal\r\n         */\r\n        this.componentControls = new Set();\r\n    }\r\n    /**\r\n     * Set variants on this and all child components.\r\n     *\r\n     * @param variants - The variants to set\r\n     *\r\n     * @internal\r\n     */\r\n    AnimationControls.prototype.setVariants = function (variants) {\r\n        this.variants = variants;\r\n        this.componentControls.forEach(function (controls) {\r\n            return controls.setVariants(variants);\r\n        });\r\n    };\r\n    /**\r\n     * Set a default transition on this and all child components\r\n     *\r\n     * @param transition - The default transition to set\r\n     *\r\n     * @internal\r\n     */\r\n    AnimationControls.prototype.setDefaultTransition = function (transition) {\r\n        this.defaultTransition = transition;\r\n        this.componentControls.forEach(function (controls) {\r\n            return controls.setDefaultTransition(transition);\r\n        });\r\n    };\r\n    /**\r\n     * Subscribes a component's animation controls to this.\r\n     *\r\n     * @param controls - The controls to subscribe\r\n     * @returns An unsubscribe function.\r\n     *\r\n     * @internal\r\n     */\r\n    AnimationControls.prototype.subscribe = function (controls) {\r\n        var _this = this;\r\n        this.componentControls.add(controls);\r\n        if (this.variants)\r\n            controls.setVariants(this.variants);\r\n        if (this.defaultTransition)\r\n            controls.setDefaultTransition(this.defaultTransition);\r\n        return function () { return _this.componentControls.delete(controls); };\r\n    };\r\n    /**\r\n     * Starts an animation on all linked components.\r\n     *\r\n     * @remarks\r\n     *\r\n     * ```jsx\r\n     * controls.start(\"variantLabel\")\r\n     * controls.start({\r\n     *   x: 0,\r\n     *   transition: { duration: 1 }\r\n     * })\r\n     * ```\r\n     *\r\n     * @param definition - Properties or variant label to animate to\r\n     * @param transition - Optional `transtion` to apply to a variant\r\n     * @returns - A `Promise` that resolves when all animations have completed.\r\n     *\r\n     * @public\r\n     */\r\n    AnimationControls.prototype.start = function (definition, transitionOverride) {\r\n        var _this = this;\r\n        if (this.hasMounted) {\r\n            var animations_1 = [];\r\n            this.componentControls.forEach(function (controls) {\r\n                var animation = controls.start(definition, {\r\n                    transitionOverride: transitionOverride,\r\n                });\r\n                animations_1.push(animation);\r\n            });\r\n            return Promise.all(animations_1);\r\n        }\r\n        else {\r\n            return new Promise(function (resolve) {\r\n                _this.pendingAnimations.push({\r\n                    animation: [definition, transitionOverride],\r\n                    resolve: resolve,\r\n                });\r\n            });\r\n        }\r\n    };\r\n    /**\r\n     * Instantly set to a set of properties or a variant.\r\n     *\r\n     * ```jsx\r\n     * // With properties\r\n     * controls.set({ opacity: 0 })\r\n     *\r\n     * // With variants\r\n     * controls.set(\"hidden\")\r\n     * ```\r\n     *\r\n     * @internalremarks\r\n     * We could perform a similar trick to `.start` where this can be called before mount\r\n     * and we maintain a list of of pending actions that get applied on mount. But the\r\n     * expectation of `set` is that it happens synchronously and this would be difficult\r\n     * to do before any children have even attached themselves. It's also poor practise\r\n     * and we should discourage render-synchronous `.start` calls rather than lean into this.\r\n     *\r\n     * @public\r\n     */\r\n    AnimationControls.prototype.set = function (definition) {\r\n        invariant(this.hasMounted, \"controls.set() should only be called after a component has mounted. Consider calling within a useEffect hook.\");\r\n        return this.componentControls.forEach(function (controls) {\r\n            return controls.apply(definition);\r\n        });\r\n    };\r\n    /**\r\n     * Stops animations on all linked components.\r\n     *\r\n     * ```jsx\r\n     * controls.stop()\r\n     * ```\r\n     *\r\n     * @public\r\n     */\r\n    AnimationControls.prototype.stop = function () {\r\n        this.componentControls.forEach(function (controls) { return controls.stop(); });\r\n    };\r\n    /**\r\n     * Initialises the animation controls.\r\n     *\r\n     * @internal\r\n     */\r\n    AnimationControls.prototype.mount = function () {\r\n        var _this = this;\r\n        this.hasMounted = true;\r\n        this.pendingAnimations.forEach(function (_a) {\r\n            var animation = _a.animation, resolve = _a.resolve;\r\n            return _this.start.apply(_this, animation).then(resolve);\r\n        });\r\n    };\r\n    /**\r\n     * Stops all child animations when the host component unmounts.\r\n     *\r\n     * @internal\r\n     */\r\n    AnimationControls.prototype.unmount = function () {\r\n        this.hasMounted = false;\r\n        this.stop();\r\n    };\r\n    return AnimationControls;\r\n}());\r\n/**\r\n * @internal\r\n */\r\nvar animationControls = function () { return new AnimationControls(); };\n\nvar PresenceContext = createContext(null);\n\n/**\r\n * @internal\r\n */\r\nvar MotionContext = createContext({\r\n    static: false,\r\n});\r\nvar isVariantLabel = function (v) {\r\n    return typeof v === \"string\" || Array.isArray(v);\r\n};\r\nvar isAnimationControls = function (v) {\r\n    return v instanceof AnimationControls;\r\n};\r\n/**\r\n * Set up the context for children motion components.\r\n *\r\n * We also use this opportunity to apply `initial` values\r\n */\r\nvar useMotionContext = function (parentContext, controls, values, isStatic, _a) {\r\n    if (isStatic === void 0) { isStatic = false; }\r\n    var initial = _a.initial, animate = _a.animate, variants = _a.variants, whileTap = _a.whileTap, whileHover = _a.whileHover;\r\n    var _b;\r\n    var presenceContext = useContext(PresenceContext);\r\n    // Override initial with that from a parent context, if defined\r\n    if (((_b = presenceContext) === null || _b === void 0 ? void 0 : _b.initial) !== undefined) {\r\n        initial = presenceContext.initial;\r\n    }\r\n    var initialState;\r\n    if (initial === false && !isAnimationControls(animate)) {\r\n        initialState = animate;\r\n    }\r\n    else if (typeof initial !== \"boolean\") {\r\n        initialState = initial;\r\n    }\r\n    // Track mounted status so children can detect whether they were present during their\r\n    // parent's first render\r\n    var hasMounted = useRef(false);\r\n    // We propagate this component's ValueAnimationControls *if* we're being provided variants,\r\n    // if we're being used to control variants, or if we're being passed animation controls.\r\n    // Otherwise this component should be \"invisible\" to variant propagation. This is a slight concession\r\n    // to Framer X where every `Frame` is a `motion` component and it might be if we change that in the future\r\n    // that this restriction is removed.\r\n    var shouldPropagateControls = variants ||\r\n        isVariantLabel(animate) ||\r\n        isVariantLabel(whileTap) ||\r\n        isVariantLabel(whileHover) ||\r\n        isAnimationControls(animate);\r\n    // If this component's `initial` prop is a variant label, propagate it. Otherwise pass the parent's.\r\n    var targetInitial = isVariantLabel(initialState)\r\n        ? initialState\r\n        : parentContext.initial;\r\n    // If this is a variant tree we need to propagate the `animate` prop in case new children are added after\r\n    // the tree initially animates.\r\n    var targetAnimate = isVariantLabel(animate)\r\n        ? animate\r\n        : parentContext.animate;\r\n    // Only allow `initial` to trigger context re-renders if this is a `static` component (ie we're on the Framer canvas)\r\n    // or in another non-animation/interaction environment.\r\n    var initialDependency = isStatic ? targetInitial : null;\r\n    // Only allow `animate` to trigger context re-renders if it's a variant label. If this is an array of\r\n    // variant labels there's probably an optimisation to deep-compare but it might be an over-optimisation.\r\n    // We want to do this as we rely on React's component rendering order each render cycle to determine\r\n    // the new order of any child components for the `staggerChildren` functionality.\r\n    var animateDependency = shouldPropagateControls && isVariantLabel(targetAnimate)\r\n        ? targetAnimate\r\n        : null;\r\n    // The context to provide to the child. We `useMemo` because although `controls` and `initial` are\r\n    // unlikely to change, by making the context an object it'll be considered a new value every render.\r\n    // So all child motion components will re-render as a result.\r\n    var context = useMemo(function () { return ({\r\n        controls: shouldPropagateControls\r\n            ? controls\r\n            : parentContext.controls,\r\n        initial: targetInitial,\r\n        animate: targetAnimate,\r\n        values: values,\r\n        hasMounted: hasMounted,\r\n        isReducedMotion: parentContext.isReducedMotion,\r\n    }); }, [initialDependency, animateDependency, parentContext.isReducedMotion]);\r\n    // Update the `static` property every render. This is unlikely to change but also essentially free.\r\n    context.static = isStatic;\r\n    // Set initial state. If this is a static component (ie in Framer canvas), respond to updates\r\n    // in `initial`.\r\n    useInitialOrEveryRender(function () {\r\n        var initialToApply = initialState || parentContext.initial;\r\n        initialToApply && controls.apply(initialToApply);\r\n    }, !isStatic);\r\n    useEffect(function () {\r\n        hasMounted.current = true;\r\n    }, []);\r\n    return context;\r\n};\n\n/**\r\n * Creates an imperative set of controls to trigger animations.\r\n *\r\n * This allows a consolidated, uniform API for animations, to be triggered by other APIs like the `animate` prop, or the gesture handlers.\r\n *\r\n * @param values\r\n * @param props\r\n * @param ref\r\n * @param subscribeToParentControls\r\n *\r\n * @internal\r\n */\r\nfunction useValueAnimationControls(config, props, subscribeToParentControls) {\r\n    var variants = props.variants, transition = props.transition;\r\n    var parentControls = useContext(MotionContext).controls;\r\n    var presenceContext = useContext(PresenceContext);\r\n    var controls = useConstant(function () { return new ValueAnimationControls(config); });\r\n    // Reset and resubscribe children every render to ensure stagger order is correct\r\n    if (!presenceContext || presenceContext.isPresent) {\r\n        controls.resetChildren();\r\n        controls.setProps(props);\r\n        controls.setVariants(variants);\r\n        controls.setDefaultTransition(transition);\r\n    }\r\n    // We have to subscribe to the parent controls within a useEffect rather than during render,\r\n    // as\r\n    useEffect(function () {\r\n        if (subscribeToParentControls && parentControls) {\r\n            parentControls.addChild(controls);\r\n        }\r\n    });\r\n    useEffect(function () {\r\n        return function () {\r\n            // Remove reference to onAnimationComplete from controls. All the MotionValues\r\n            // are unsubscribed from this component separately. We let animations run out\r\n            // as they might be animating other components.\r\n            var onAnimationComplete = props.onAnimationComplete, unmountProps = __rest(props, [\"onAnimationComplete\"]);\r\n            controls.setProps(unmountProps);\r\n            parentControls && parentControls.removeChild(controls);\r\n        };\r\n    }, []);\r\n    return controls;\r\n}\n\nvar checkShouldInheritVariant = function (_a) {\r\n    var animate = _a.animate, variants = _a.variants, _b = _a.inherit, inherit = _b === void 0 ? true : _b;\r\n    return (inherit &&\r\n        !!variants &&\r\n        (!animate || animate instanceof AnimationControls));\r\n};\n\n/**\r\n * Uses the ref that is passed in, or creates a new one\r\n * @param external - External ref\r\n * @internal\r\n */\r\nfunction useExternalRef(externalRef) {\r\n    // We're conditionally calling `useRef` here which is sort of naughty as hooks\r\n    // shouldn't be called conditionally. However, Framer Motion will break if this\r\n    // condition changes anyway. It might be possible to use an invariant here to\r\n    // make it explicit, but I expect changing `ref` is not normal behaviour.\r\n    var ref = !externalRef || typeof externalRef === \"function\"\r\n        ? useRef(null)\r\n        : externalRef;\r\n    // Handle `ref` functions. Again, calling the hook conditionally is kind of naughty\r\n    // but `ref` types changing between renders would break Motion anyway. If we receive\r\n    // bug reports about this, we should track the provided ref and throw an invariant\r\n    // rather than move the conditional to inside the useEffect as this will be fired\r\n    // for every Frame component within Framer.\r\n    if (externalRef && typeof externalRef === \"function\") {\r\n        useEffect(function () {\r\n            externalRef(ref.current);\r\n            return function () { return externalRef(null); };\r\n        }, []);\r\n    }\r\n    return ref;\r\n}\n\n/**\r\n * @internal\r\n */\r\nvar createMotionComponent = function (_a) {\r\n    var getValueControlsConfig = _a.getValueControlsConfig, loadFunctionalityComponents = _a.loadFunctionalityComponents, renderComponent = _a.renderComponent;\r\n    function MotionComponent(props, externalRef) {\r\n        var ref = useExternalRef(externalRef);\r\n        var parentContext = useContext(MotionContext);\r\n        var isStatic = parentContext.static || props.static || false;\r\n        var values = useMotionValues(props);\r\n        var style = useMotionStyles(values, props.style, isStatic, props.transformValues);\r\n        var shouldInheritVariant = checkShouldInheritVariant(props);\r\n        var controlsConfig = useConstant(function () {\r\n            return getValueControlsConfig(ref, values);\r\n        });\r\n        var controls = useValueAnimationControls(controlsConfig, props, shouldInheritVariant);\r\n        var context = useMotionContext(parentContext, controls, values, isStatic, props);\r\n        var functionality = isStatic\r\n            ? null\r\n            : loadFunctionalityComponents(ref, values, props, parentContext, controls, shouldInheritVariant);\r\n        var renderedComponent = renderComponent(ref, style, values, props, isStatic);\r\n        return (createElement(Fragment, null,\r\n            createElement(MotionContext.Provider, { value: context }, renderedComponent),\r\n            createElement(Fragment, null,\r\n                createElement(Mount, { innerRef: ref, values: values, isStatic: isStatic }),\r\n                functionality)));\r\n    }\r\n    return forwardRef(MotionComponent);\r\n};\n\n/**\r\n * @internal\r\n */\r\nvar htmlElements = [\r\n    \"a\",\r\n    \"abbr\",\r\n    \"address\",\r\n    \"area\",\r\n    \"article\",\r\n    \"aside\",\r\n    \"audio\",\r\n    \"b\",\r\n    \"base\",\r\n    \"bdi\",\r\n    \"bdo\",\r\n    \"big\",\r\n    \"blockquote\",\r\n    \"body\",\r\n    \"br\",\r\n    \"button\",\r\n    \"canvas\",\r\n    \"caption\",\r\n    \"cite\",\r\n    \"code\",\r\n    \"col\",\r\n    \"colgroup\",\r\n    \"data\",\r\n    \"datalist\",\r\n    \"dd\",\r\n    \"del\",\r\n    \"details\",\r\n    \"dfn\",\r\n    \"dialog\",\r\n    \"div\",\r\n    \"dl\",\r\n    \"dt\",\r\n    \"em\",\r\n    \"embed\",\r\n    \"fieldset\",\r\n    \"figcaption\",\r\n    \"figure\",\r\n    \"footer\",\r\n    \"form\",\r\n    \"h1\",\r\n    \"h2\",\r\n    \"h3\",\r\n    \"h4\",\r\n    \"h5\",\r\n    \"h6\",\r\n    \"head\",\r\n    \"header\",\r\n    \"hgroup\",\r\n    \"hr\",\r\n    \"html\",\r\n    \"i\",\r\n    \"iframe\",\r\n    \"img\",\r\n    \"input\",\r\n    \"ins\",\r\n    \"kbd\",\r\n    \"keygen\",\r\n    \"label\",\r\n    \"legend\",\r\n    \"li\",\r\n    \"link\",\r\n    \"main\",\r\n    \"map\",\r\n    \"mark\",\r\n    \"menu\",\r\n    \"menuitem\",\r\n    \"meta\",\r\n    \"meter\",\r\n    \"nav\",\r\n    \"noscript\",\r\n    \"object\",\r\n    \"ol\",\r\n    \"optgroup\",\r\n    \"option\",\r\n    \"output\",\r\n    \"p\",\r\n    \"param\",\r\n    \"picture\",\r\n    \"pre\",\r\n    \"progress\",\r\n    \"q\",\r\n    \"rp\",\r\n    \"rt\",\r\n    \"ruby\",\r\n    \"s\",\r\n    \"samp\",\r\n    \"script\",\r\n    \"section\",\r\n    \"select\",\r\n    \"small\",\r\n    \"source\",\r\n    \"span\",\r\n    \"strong\",\r\n    \"style\",\r\n    \"sub\",\r\n    \"summary\",\r\n    \"sup\",\r\n    \"table\",\r\n    \"tbody\",\r\n    \"td\",\r\n    \"textarea\",\r\n    \"tfoot\",\r\n    \"th\",\r\n    \"thead\",\r\n    \"time\",\r\n    \"title\",\r\n    \"tr\",\r\n    \"track\",\r\n    \"u\",\r\n    \"ul\",\r\n    \"var\",\r\n    \"video\",\r\n    \"wbr\",\r\n    \"webview\",\r\n];\r\n/**\r\n * @internal\r\n */\r\nvar svgElements = [\r\n    \"animate\",\r\n    \"circle\",\r\n    \"clipPath\",\r\n    \"defs\",\r\n    \"desc\",\r\n    \"ellipse\",\r\n    \"feBlend\",\r\n    \"feColorMatrix\",\r\n    \"feComponentTransfer\",\r\n    \"feComposite\",\r\n    \"feConvolveMatrix\",\r\n    \"feDiffuseLighting\",\r\n    \"feDisplacementMap\",\r\n    \"feDistantLight\",\r\n    \"feDropShadow\",\r\n    \"feFlood\",\r\n    \"feFuncA\",\r\n    \"feFuncB\",\r\n    \"feFuncG\",\r\n    \"feFuncR\",\r\n    \"feGaussianBlur\",\r\n    \"feImage\",\r\n    \"feMerge\",\r\n    \"feMergeNode\",\r\n    \"feMorphology\",\r\n    \"feOffset\",\r\n    \"fePointLight\",\r\n    \"feSpecularLighting\",\r\n    \"feSpotLight\",\r\n    \"feTile\",\r\n    \"feTurbulence\",\r\n    \"filter\",\r\n    \"foreignObject\",\r\n    \"g\",\r\n    \"image\",\r\n    \"line\",\r\n    \"linearGradient\",\r\n    \"marker\",\r\n    \"mask\",\r\n    \"metadata\",\r\n    \"path\",\r\n    \"pattern\",\r\n    \"polygon\",\r\n    \"polyline\",\r\n    \"radialGradient\",\r\n    \"rect\",\r\n    \"stop\",\r\n    \"svg\",\r\n    \"switch\",\r\n    \"symbol\",\r\n    \"text\",\r\n    \"textPath\",\r\n    \"tspan\",\r\n    \"use\",\r\n    \"view\",\r\n];\n\n/**\r\n * @internal\r\n */\r\nvar MotionPluginContext = createContext({\r\n    transformPagePoint: function (p) { return p; },\r\n});\r\n/**\r\n * @remarks For now I think this should remain a private API for our own use\r\n * until we can figure out a nicer way of allowing people to add these\r\n *\r\n * @internal\r\n */\r\nfunction MotionPlugins(_a) {\r\n    var children = _a.children, props = __rest(_a, [\"children\"]);\r\n    var pluginContext = useContext(MotionPluginContext);\r\n    var value = useRef(__assign({}, pluginContext)).current;\r\n    // Mutative to prevent triggering rerenders in all listening\r\n    // components every time this component renders\r\n    for (var key in props) {\r\n        value[key] = props[key];\r\n    }\r\n    return (createElement(MotionPluginContext.Provider, { value: value }, children));\r\n}\n\nfunction useUnmountEffect(callback) {\r\n    return useEffect(function () { return function () { return callback(); }; }, []);\r\n}\n\nfunction addDomEvent(target, eventName, handler, options) {\r\n    if (!handler)\r\n        return;\r\n    target.addEventListener(eventName, handler, options);\r\n    return function () { return target.removeEventListener(eventName, handler, options); };\r\n}\r\n/**\r\n * Attaches an event listener directly to the provided DOM element.\r\n *\r\n * Bypassing React's event system can be desirable, for instance when attaching non-passive\r\n * event handlers.\r\n *\r\n * ```jsx\r\n * const ref = useRef(null)\r\n *\r\n * useDomEvent(ref, 'wheel', onWheel, { passive: false })\r\n *\r\n * return <div ref={ref} />\r\n * ```\r\n *\r\n * @param ref - React.RefObject that's been provided to the element you want to bind the listener to.\r\n * @param eventName - Name of the event you want listen for.\r\n * @param handler - Function to fire when receiving the event.\r\n * @param options - Options to pass to `Event.addEventListener`.\r\n *\r\n * @public\r\n */\r\nfunction useDomEvent(ref, eventName, handler, options) {\r\n    useEffect(function () {\r\n        var element = ref.current;\r\n        if (handler && element) {\r\n            return addDomEvent(element, eventName, handler, options);\r\n        }\r\n    }, [ref, eventName, handler, options]);\r\n}\n\nfunction isMouseEvent(event) {\r\n    // PointerEvent inherits from MouseEvent so we can't use a straight instanceof check.\r\n    if (typeof PointerEvent !== \"undefined\" && event instanceof PointerEvent) {\r\n        return !!(event.pointerType === \"mouse\");\r\n    }\r\n    return event instanceof MouseEvent;\r\n}\r\nfunction isTouchEvent(event) {\r\n    var hasTouches = !!event.touches;\r\n    return hasTouches;\r\n}\n\n/**\r\n * Filters out events not attached to the primary pointer (currently left mouse button)\r\n * @param eventHandler\r\n */\r\nfunction filterPrimaryPointer(eventHandler) {\r\n    if (!eventHandler)\r\n        return undefined;\r\n    return function (event) {\r\n        var isMouseEvent = event instanceof MouseEvent;\r\n        var isPrimaryPointer = !isMouseEvent ||\r\n            (isMouseEvent && event.button === 0);\r\n        if (isPrimaryPointer) {\r\n            eventHandler(event);\r\n        }\r\n    };\r\n}\r\nvar defaultPagePoint = { pageX: 0, pageY: 0 };\r\nfunction pointFromTouch(e) {\r\n    var primaryTouch = e.touches[0] || e.changedTouches[0];\r\n    var _a = primaryTouch || defaultPagePoint, pageX = _a.pageX, pageY = _a.pageY;\r\n    return { x: pageX, y: pageY };\r\n}\r\nfunction pointFromMouse(_a) {\r\n    var _b = _a.pageX, pageX = _b === void 0 ? 0 : _b, _c = _a.pageY, pageY = _c === void 0 ? 0 : _c;\r\n    return { x: pageX, y: pageY };\r\n}\r\nfunction extractEventInfo(event) {\r\n    return {\r\n        point: isTouchEvent(event)\r\n            ? pointFromTouch(event)\r\n            : pointFromMouse(event),\r\n    };\r\n}\r\nvar wrapHandler = function (handler, shouldFilterPrimaryPointer) {\r\n    if (shouldFilterPrimaryPointer === void 0) { shouldFilterPrimaryPointer = false; }\r\n    if (!handler)\r\n        return;\r\n    var listener = function (event) { return handler(event, extractEventInfo(event)); };\r\n    return shouldFilterPrimaryPointer\r\n        ? filterPrimaryPointer(listener)\r\n        : listener;\r\n};\n\nvar isBrowser = typeof window !== \"undefined\";\r\n// We check for event support via functions in case they've been mocked by a testing suite.\r\nvar supportsPointerEvents = function () {\r\n    return isBrowser && window.onpointerdown === null;\r\n};\r\nvar supportsTouchEvents = function () {\r\n    return isBrowser && window.ontouchstart === null;\r\n};\r\nvar supportsMouseEvents = function () {\r\n    return isBrowser && window.onmousedown === null;\r\n};\n\nvar mouseEventNames = {\r\n    pointerdown: \"mousedown\",\r\n    pointermove: \"mousemove\",\r\n    pointerup: \"mouseup\",\r\n    pointercancel: \"mousecancel\",\r\n    pointerover: \"mouseover\",\r\n    pointerout: \"mouseout\",\r\n    pointerenter: \"mouseenter\",\r\n    pointerleave: \"mouseleave\",\r\n};\r\nvar touchEventNames = {\r\n    pointerdown: \"touchstart\",\r\n    pointermove: \"touchmove\",\r\n    pointerup: \"touchend\",\r\n    pointercancel: \"touchcancel\",\r\n};\r\nfunction getPointerEventName(name) {\r\n    if (supportsPointerEvents()) {\r\n        return name;\r\n    }\r\n    else if (supportsTouchEvents()) {\r\n        return touchEventNames[name];\r\n    }\r\n    else if (supportsMouseEvents()) {\r\n        return mouseEventNames[name];\r\n    }\r\n    return name;\r\n}\r\nfunction addPointerEvent(target, eventName, handler, options) {\r\n    return addDomEvent(target, getPointerEventName(eventName), wrapHandler(handler, eventName === \"pointerdown\"), options);\r\n}\r\nfunction usePointerEvent(ref, eventName, handler, options) {\r\n    return useDomEvent(ref, getPointerEventName(eventName), wrapHandler(handler, eventName === \"pointerdown\"), options);\r\n}\n\n/** @public */\r\nvar Point;\r\n(function (Point) {\r\n    /** @beta */\r\n    Point.subtract = function (a, b) {\r\n        return { x: a.x - b.x, y: a.y - b.y };\r\n    };\r\n    /** @beta */\r\n    Point.relativeTo = function (idOrElem) {\r\n        var elem;\r\n        var getElem = function () {\r\n            // Caching element here could be leaky because of React lifecycle\r\n            if (elem !== undefined)\r\n                return elem;\r\n            if (typeof idOrElem === \"string\") {\r\n                elem = document.getElementById(idOrElem);\r\n            }\r\n            else {\r\n                elem = idOrElem;\r\n            }\r\n            return elem;\r\n        };\r\n        return function (_a) {\r\n            var x = _a.x, y = _a.y;\r\n            var localElem = getElem();\r\n            if (!localElem)\r\n                return undefined;\r\n            var rect = localElem.getBoundingClientRect();\r\n            return {\r\n                x: x - rect.left - window.scrollX,\r\n                y: y - rect.top - window.scrollY,\r\n            };\r\n        };\r\n    };\r\n})(Point || (Point = {}));\n\nvar isViewportScrollBlocked = false;\r\nvar isBrowser$1 = typeof window !== \"undefined\";\r\nif (isBrowser$1) {\r\n    document.addEventListener(\"touchmove\", function (event) {\r\n        if (isViewportScrollBlocked) {\r\n            event.preventDefault();\r\n        }\r\n    }, { passive: false });\r\n}\r\nvar blockViewportScroll = function () { return (isViewportScrollBlocked = true); };\r\nvar unblockViewportScroll = function () { return (isViewportScrollBlocked = false); };\n\n/**\r\n * @internal\r\n */\r\nvar PanSession = /** @class */ (function () {\r\n    function PanSession(event, handlers, _a) {\r\n        var _this = this;\r\n        var transformPagePoint = (_a === void 0 ? {} : _a).transformPagePoint;\r\n        /**\r\n         * @internal\r\n         */\r\n        this.startEvent = null;\r\n        /**\r\n         * @internal\r\n         */\r\n        this.lastMoveEvent = null;\r\n        /**\r\n         * @internal\r\n         */\r\n        this.lastMoveEventInfo = null;\r\n        /**\r\n         * @internal\r\n         */\r\n        this.handlers = {};\r\n        this.updatePoint = function () {\r\n            if (!(_this.lastMoveEvent && _this.lastMoveEventInfo))\r\n                return;\r\n            var info = getPanInfo(_this.lastMoveEventInfo, _this.history);\r\n            var isPanStarted = _this.startEvent !== null;\r\n            // Only start panning if the offset is larger than 3 pixels. If we make it\r\n            // any larger than this we'll want to reset the pointer history\r\n            // on the first update to avoid visual snapping to the cursoe.\r\n            var isDistancePastThreshold = distance(info.offset, { x: 0, y: 0 }) >= 3;\r\n            if (!isPanStarted && !isDistancePastThreshold)\r\n                return;\r\n            var point = info.point;\r\n            var timestamp = getFrameData().timestamp;\r\n            _this.history.push(__assign(__assign({}, point), { timestamp: timestamp }));\r\n            var _a = _this.handlers, onStart = _a.onStart, onMove = _a.onMove;\r\n            if (!isPanStarted) {\r\n                onStart && onStart(_this.lastMoveEvent, info);\r\n                _this.startEvent = _this.lastMoveEvent;\r\n            }\r\n            onMove && onMove(_this.lastMoveEvent, info);\r\n        };\r\n        // If we have more than one touch, don't start detecting this gesture\r\n        if (isTouchEvent(event) && event.touches.length > 1)\r\n            return;\r\n        this.handlers = handlers;\r\n        this.transformPagePoint = transformPagePoint;\r\n        var info = extractEventInfo(event);\r\n        var initialInfo = transformPoint(info, this.transformPagePoint);\r\n        var point = initialInfo.point;\r\n        var timestamp = getFrameData().timestamp;\r\n        this.history = [__assign(__assign({}, point), { timestamp: timestamp })];\r\n        var onSessionStart = handlers.onSessionStart;\r\n        onSessionStart &&\r\n            onSessionStart(event, getPanInfo(initialInfo, this.history));\r\n        var removeOnPointerMove = addPointerEvent(window, \"pointermove\", function (event, info) { return _this.handlePointerMove(event, info); });\r\n        var removeOnPointerUp = addPointerEvent(window, \"pointerup\", function (event, info) { return _this.handlePointerUp(event, info); });\r\n        this.removeListeners = function () {\r\n            removeOnPointerMove && removeOnPointerMove();\r\n            removeOnPointerUp && removeOnPointerUp();\r\n        };\r\n    }\r\n    PanSession.prototype.handlePointerMove = function (event, info) {\r\n        this.lastMoveEvent = event;\r\n        this.lastMoveEventInfo = transformPoint(info, this.transformPagePoint);\r\n        // Because Safari doesn't trigger mouseup events when it's above a `<select>`\r\n        if (isMouseEvent(event) && event.buttons === 0) {\r\n            this.handlePointerUp(event, info);\r\n            return;\r\n        }\r\n        // Throttle mouse move event to once per frame\r\n        sync.update(this.updatePoint, true);\r\n    };\r\n    PanSession.prototype.handlePointerUp = function (event, info) {\r\n        this.end();\r\n        var onEnd = this.handlers.onEnd;\r\n        if (!onEnd)\r\n            return;\r\n        var panInfo = getPanInfo(transformPoint(info, this.transformPagePoint), this.history);\r\n        onEnd && onEnd(event, panInfo);\r\n    };\r\n    PanSession.prototype.updateHandlers = function (handlers) {\r\n        this.handlers = handlers;\r\n    };\r\n    PanSession.prototype.end = function () {\r\n        this.removeListeners && this.removeListeners();\r\n        cancelSync.update(this.updatePoint);\r\n        unblockViewportScroll();\r\n    };\r\n    return PanSession;\r\n}());\r\nfunction transformPoint(info, transformPagePoint) {\r\n    return transformPagePoint ? { point: transformPagePoint(info.point) } : info;\r\n}\r\nfunction getPanInfo(_a, history) {\r\n    var point = _a.point;\r\n    return {\r\n        point: point,\r\n        delta: Point.subtract(point, lastDevicePoint(history)),\r\n        offset: Point.subtract(point, startDevicePoint(history)),\r\n        velocity: getVelocity$1(history, 0.1),\r\n    };\r\n}\r\nfunction startDevicePoint(history) {\r\n    return history[0];\r\n}\r\nfunction lastDevicePoint(history) {\r\n    return history[history.length - 1];\r\n}\r\nfunction getVelocity$1(history, timeDelta) {\r\n    if (history.length < 2) {\r\n        return { x: 0, y: 0 };\r\n    }\r\n    var i = history.length - 1;\r\n    var timestampedPoint = null;\r\n    var lastPoint = lastDevicePoint(history);\r\n    while (i >= 0) {\r\n        timestampedPoint = history[i];\r\n        if (lastPoint.timestamp - timestampedPoint.timestamp >\r\n            secondsToMilliseconds(timeDelta)) {\r\n            break;\r\n        }\r\n        i--;\r\n    }\r\n    if (!timestampedPoint) {\r\n        return { x: 0, y: 0 };\r\n    }\r\n    var time = (lastPoint.timestamp - timestampedPoint.timestamp) / 1000;\r\n    if (time === 0) {\r\n        return { x: 0, y: 0 };\r\n    }\r\n    var currentVelocity = {\r\n        x: (lastPoint.x - timestampedPoint.x) / time,\r\n        y: (lastPoint.y - timestampedPoint.y) / time,\r\n    };\r\n    if (currentVelocity.x === Infinity) {\r\n        currentVelocity.x = 0;\r\n    }\r\n    if (currentVelocity.y === Infinity) {\r\n        currentVelocity.y = 0;\r\n    }\r\n    return currentVelocity;\r\n}\n\n/**\r\n *\r\n * @param handlers -\r\n * @param ref -\r\n *\r\n * @internalremarks\r\n * Currently this sets new pan gesture functions every render. The memo route has been explored\r\n * in the past but ultimately we're still creating new functions every render. An optimisation\r\n * to explore is creating the pan gestures and loading them into a `ref`.\r\n *\r\n * @internal\r\n */\r\nfunction usePanGesture(_a, ref) {\r\n    var onPan = _a.onPan, onPanStart = _a.onPanStart, onPanEnd = _a.onPanEnd, onPanSessionStart = _a.onPanSessionStart;\r\n    var hasPanEvents = onPan || onPanStart || onPanEnd || onPanSessionStart;\r\n    var panSession = useRef(null);\r\n    var transformPagePoint = useContext(MotionPluginContext).transformPagePoint;\r\n    var handlers = {\r\n        onSessionStart: onPanSessionStart,\r\n        onStart: onPanStart,\r\n        onMove: onPan,\r\n        onEnd: function (event, info) {\r\n            panSession.current = null;\r\n            onPanEnd && onPanEnd(event, info);\r\n        },\r\n    };\r\n    if (panSession.current !== null) {\r\n        panSession.current.updateHandlers(handlers);\r\n    }\r\n    function onPointerDown(event) {\r\n        panSession.current = new PanSession(event, handlers, {\r\n            transformPagePoint: transformPagePoint,\r\n        });\r\n    }\r\n    usePointerEvent(ref, \"pointerdown\", hasPanEvents && onPointerDown);\r\n    useUnmountEffect(function () { return panSession.current && panSession.current.end(); });\r\n}\n\n/**\r\n * Recursively traverse up the tree to check whether the provided child node\r\n * is the parent or a descendant of it.\r\n *\r\n * @param parent - Element to find\r\n * @param child - Element to test against parent\r\n */\r\nvar isNodeOrChild = function (parent, child) {\r\n    if (!child) {\r\n        return false;\r\n    }\r\n    else if (parent === child) {\r\n        return true;\r\n    }\r\n    else {\r\n        return isNodeOrChild(parent, child.parentElement);\r\n    }\r\n};\n\nvar order = [\"whileHover\", \"whileTap\", \"whileDrag\"];\r\nvar getGesturePriority = function (gesture) {\r\n    return order.indexOf(gesture) + 1;\r\n};\n\nfunction createLock(name) {\r\n    var lock = null;\r\n    return function () {\r\n        var openLock = function () {\r\n            lock = null;\r\n        };\r\n        if (lock === null) {\r\n            lock = name;\r\n            return openLock;\r\n        }\r\n        return false;\r\n    };\r\n}\r\nvar globalHorizontalLock = createLock(\"dragHorizontal\");\r\nvar globalVerticalLock = createLock(\"dragVertical\");\r\nfunction getGlobalLock(drag) {\r\n    var lock = false;\r\n    if (drag === \"y\") {\r\n        lock = globalVerticalLock();\r\n    }\r\n    else if (drag === \"x\") {\r\n        lock = globalHorizontalLock();\r\n    }\r\n    else {\r\n        var openHorizontal_1 = globalHorizontalLock();\r\n        var openVertical_1 = globalVerticalLock();\r\n        if (openHorizontal_1 && openVertical_1) {\r\n            lock = function () {\r\n                openHorizontal_1();\r\n                openVertical_1();\r\n            };\r\n        }\r\n        else {\r\n            // Release the locks because we don't use them\r\n            if (openHorizontal_1)\r\n                openHorizontal_1();\r\n            if (openVertical_1)\r\n                openVertical_1();\r\n        }\r\n    }\r\n    return lock;\r\n}\n\nvar tapGesturePriority = getGesturePriority(\"whileTap\");\r\n/**\r\n * @param handlers -\r\n * @internal\r\n */\r\nfunction useTapGesture(_a, ref) {\r\n    var onTap = _a.onTap, onTapStart = _a.onTapStart, onTapCancel = _a.onTapCancel, whileTap = _a.whileTap, controls = _a.controls;\r\n    var hasTapListeners = onTap || onTapStart || onTapCancel || whileTap;\r\n    var isTapping = useRef(false);\r\n    var cancelPointerEventListener = useRef(null);\r\n    function removePointerUp() {\r\n        cancelPointerEventListener.current &&\r\n            cancelPointerEventListener.current();\r\n        cancelPointerEventListener.current = null;\r\n    }\r\n    if (whileTap && controls) {\r\n        controls.setOverride(whileTap, tapGesturePriority);\r\n    }\r\n    // We load this event handler into a ref so we can later refer to\r\n    // onPointerUp.current which will always have reference to the latest props\r\n    var onPointerUp = useRef(null);\r\n    onPointerUp.current = function (event, info) {\r\n        var element = ref.current;\r\n        removePointerUp();\r\n        if (!isTapping.current || !element)\r\n            return;\r\n        isTapping.current = false;\r\n        if (controls && whileTap) {\r\n            controls.clearOverride(tapGesturePriority);\r\n        }\r\n        // Check the gesture lock - if we get it, it means no drag gesture is active\r\n        // and we can safely fire the tap gesture.\r\n        var openGestureLock = getGlobalLock(true);\r\n        if (!openGestureLock)\r\n            return;\r\n        openGestureLock();\r\n        if (!isNodeOrChild(element, event.target)) {\r\n            onTapCancel && onTapCancel(event, info);\r\n        }\r\n        else {\r\n            onTap && onTap(event, info);\r\n        }\r\n    };\r\n    function onPointerDown(event, info) {\r\n        removePointerUp();\r\n        cancelPointerEventListener.current = addPointerEvent(window, \"pointerup\", function (event, info) { return onPointerUp.current(event, info); });\r\n        var element = ref.current;\r\n        if (!element || isTapping.current)\r\n            return;\r\n        isTapping.current = true;\r\n        onTapStart && onTapStart(event, info);\r\n        if (controls && whileTap) {\r\n            controls.startOverride(tapGesturePriority);\r\n        }\r\n    }\r\n    usePointerEvent(ref, \"pointerdown\", hasTapListeners ? onPointerDown : undefined);\r\n    useUnmountEffect(removePointerUp);\r\n}\n\nvar hoverPriority = getGesturePriority(\"whileHover\");\r\nvar filterTouch = function (listener) { return function (event, info) {\r\n    if (isMouseEvent(event))\r\n        listener(event, info);\r\n}; };\r\n/**\r\n *\r\n * @param props\r\n * @param ref\r\n * @internal\r\n */\r\nfunction useHoverGesture(_a, ref) {\r\n    var whileHover = _a.whileHover, onHoverStart = _a.onHoverStart, onHoverEnd = _a.onHoverEnd, controls = _a.controls;\r\n    if (whileHover && controls) {\r\n        controls.setOverride(whileHover, hoverPriority);\r\n    }\r\n    usePointerEvent(ref, \"pointerenter\", filterTouch(function (event, info) {\r\n        if (onHoverStart)\r\n            onHoverStart(event, info);\r\n        if (whileHover && controls) {\r\n            controls.startOverride(hoverPriority);\r\n        }\r\n    }));\r\n    usePointerEvent(ref, \"pointerleave\", filterTouch(function (event, info) {\r\n        if (onHoverEnd)\r\n            onHoverEnd(event, info);\r\n        if (whileHover && controls) {\r\n            controls.clearOverride(hoverPriority);\r\n        }\r\n    }));\r\n}\n\n/**\r\n * Add pan and tap gesture recognition to an element.\r\n *\r\n * @param props - Gesture event handlers\r\n * @param ref - React `ref` containing a DOM `Element`\r\n * @public\r\n */\r\nfunction useGestures(props, ref) {\r\n    usePanGesture(props, ref);\r\n    useTapGesture(props, ref);\r\n    useHoverGesture(props, ref);\r\n}\n\nvar makeRenderlessComponent = function (hook) { return function (props) {\r\n    hook(props);\r\n    return null;\r\n}; };\n\nvar gestureProps = [\r\n    \"onPan\",\r\n    \"onPanStart\",\r\n    \"onPanEnd\",\r\n    \"onPanSessionStart\",\r\n    \"onTap\",\r\n    \"onTapStart\",\r\n    \"onTapCancel\",\r\n    \"whileTap\",\r\n    \"whileHover\",\r\n    \"onHoverStart\",\r\n    \"onHoverEnd\",\r\n];\r\nvar Gestures = {\r\n    key: \"gestures\",\r\n    shouldRender: function (props) {\r\n        return gestureProps.some(function (key) { return props.hasOwnProperty(key); });\r\n    },\r\n    Component: makeRenderlessComponent(function (_a) {\r\n        var innerRef = _a.innerRef, props = __rest(_a, [\"innerRef\"]);\r\n        useGestures(props, innerRef);\r\n    }),\r\n};\n\nvar isRefObject = function (ref) {\r\n    return typeof ref === \"object\" && ref.hasOwnProperty(\"current\");\r\n};\n\nvar noop = function (v) { return v; };\r\nvar ComponentDragControls = /** @class */ (function () {\r\n    function ComponentDragControls(_a) {\r\n        var ref = _a.ref, values = _a.values, controls = _a.controls;\r\n        /**\r\n         * Track whether we're currently dragging.\r\n         *\r\n         * @internal\r\n         */\r\n        this.isDragging = false;\r\n        /**\r\n         * The current direction of drag, or `null` if both.\r\n         *\r\n         * @internal\r\n         */\r\n        this.currentDirection = null;\r\n        /**\r\n         * The permitted t/r/b/l boundaries of travel, in pixels.\r\n         *\r\n         * @internal\r\n         */\r\n        this.constraints = false;\r\n        /**\r\n         * A reference to the host component's latest props.\r\n         *\r\n         * @internal\r\n         */\r\n        this.props = {\r\n            transformPagePoint: noop,\r\n        };\r\n        /**\r\n         * References to the MotionValues used for tracking the current dragged point.\r\n         *\r\n         * @internal\r\n         */\r\n        this.point = {};\r\n        /**\r\n         * The origin point for the current drag gesture.\r\n         *\r\n         * @internal\r\n         */\r\n        this.origin = {\r\n            x: motionValue(0),\r\n            y: motionValue(0),\r\n        };\r\n        // This is a reference to the global drag gesture lock, ensuring only one component\r\n        // can \"capture\" the drag of one or both axes.\r\n        // TODO: Look into moving this into pansession?\r\n        this.openGlobalLock = null;\r\n        /**\r\n         * @internal\r\n         */\r\n        this.panSession = null;\r\n        /**\r\n         * A reference to the previous constraints bounding box\r\n         *\r\n         * @internal\r\n         */\r\n        this.prevConstraintsBox = {\r\n            width: 0,\r\n            height: 0,\r\n            x: 0,\r\n            y: 0,\r\n        };\r\n        this.ref = ref;\r\n        this.values = values;\r\n        this.controls = controls;\r\n    }\r\n    /**\r\n     * Start dragging the host component.\r\n     *\r\n     * @param event - The originating pointer event.\r\n     * @param options -\r\n     *\r\n     * @public\r\n     */\r\n    ComponentDragControls.prototype.start = function (originEvent, _a) {\r\n        var _this = this;\r\n        var _b = (_a === void 0 ? {} : _a).snapToCursor, snapToCursor = _b === void 0 ? false : _b;\r\n        snapToCursor && this.snapToCursor(originEvent);\r\n        var onSessionStart = function () {\r\n            // Initiate viewport scroll blocking on touch start. This is a very aggressive approach\r\n            // which has come out of the difficulty in us being able to do this once a scroll gesture\r\n            // has initiated in mobile browsers. This means if there's a horizontally-scrolling carousel\r\n            // on a page we can't let a user scroll the page itself from it. Ideally what we'd do is\r\n            // trigger this once we've got a scroll direction determined. This approach sort-of worked\r\n            // but if the component was dragged too far in a single frame page scrolling would initiate.\r\n            blockViewportScroll();\r\n            // Stop any animations on both axis values immediately. This allows the user to throw and catch\r\n            // the component.\r\n            bothAxis(function (axis) {\r\n                var axisPoint = _this.point[axis];\r\n                axisPoint && axisPoint.stop();\r\n            });\r\n        };\r\n        var onStart = function (event, info) {\r\n            // If constraints are an element, resolve them again in case they've updated.\r\n            if (_this.constraintsNeedResolution) {\r\n                var _a = _this.props, dragConstraints = _a.dragConstraints, transformPagePoint_1 = _a.transformPagePoint;\r\n                _this.constraints = calculateConstraintsFromDom(dragConstraints, _this.ref, _this.point, transformPagePoint_1);\r\n                _this.applyConstraintsToPoint();\r\n            }\r\n            // Set point origin and stop any existing animations.\r\n            bothAxis(function (axis) {\r\n                var axisPoint = _this.point[axis];\r\n                if (!axisPoint)\r\n                    return;\r\n                _this.origin[axis].set(axisPoint.get());\r\n            });\r\n            // Attempt to grab the global drag gesture lock - maybe make this part of PanSession\r\n            var _b = _this.props, drag = _b.drag, dragPropagation = _b.dragPropagation;\r\n            if (drag && !dragPropagation) {\r\n                if (_this.openGlobalLock)\r\n                    _this.openGlobalLock();\r\n                _this.openGlobalLock = getGlobalLock(drag);\r\n                if (!_this.openGlobalLock)\r\n                    return;\r\n            }\r\n            _this.isDragging = true;\r\n            _this.currentDirection = null;\r\n            var onDragStart = _this.props.onDragStart;\r\n            onDragStart &&\r\n                onDragStart(event, convertPanToDrag(info, _this.point));\r\n        };\r\n        var onMove = function (event, info) {\r\n            var _a = _this.props, dragPropagation = _a.dragPropagation, dragDirectionLock = _a.dragDirectionLock;\r\n            // If we didn't successfully receive the gesture lock, early return.\r\n            if (!dragPropagation && !_this.openGlobalLock)\r\n                return;\r\n            var offset = info.offset;\r\n            // Attempt to detect drag direction if directionLock is true\r\n            if (dragDirectionLock && _this.currentDirection === null) {\r\n                _this.currentDirection = getCurrentDirection(offset);\r\n                // If we've successfully set a direction, notify listener\r\n                if (_this.currentDirection !== null) {\r\n                    var onDirectionLock = _this.props.onDirectionLock;\r\n                    onDirectionLock && onDirectionLock(_this.currentDirection);\r\n                }\r\n                return;\r\n            }\r\n            _this.updatePoint(\"x\", offset);\r\n            _this.updatePoint(\"y\", offset);\r\n            var onDrag = _this.props.onDrag;\r\n            onDrag && onDrag(event, convertPanToDrag(info, _this.point));\r\n        };\r\n        var onEnd = function (event, info) {\r\n            _this.stop(event, info);\r\n        };\r\n        var transformPagePoint = this.props.transformPagePoint;\r\n        this.panSession = new PanSession(originEvent, {\r\n            onSessionStart: onSessionStart,\r\n            onStart: onStart,\r\n            onMove: onMove,\r\n            onEnd: onEnd,\r\n        }, { transformPagePoint: transformPagePoint });\r\n    };\r\n    ComponentDragControls.prototype.cancelDrag = function () {\r\n        unblockViewportScroll();\r\n        this.isDragging = false;\r\n        this.panSession && this.panSession.end();\r\n        this.panSession = null;\r\n        if (!this.props.dragPropagation && this.openGlobalLock) {\r\n            this.openGlobalLock();\r\n            this.openGlobalLock = null;\r\n        }\r\n    };\r\n    ComponentDragControls.prototype.stop = function (event, info) {\r\n        var _a;\r\n        (_a = this.panSession) === null || _a === void 0 ? void 0 : _a.end();\r\n        this.panSession = null;\r\n        var isDragging = this.isDragging;\r\n        this.cancelDrag();\r\n        if (!isDragging)\r\n            return;\r\n        var _b = this.props, dragMomentum = _b.dragMomentum, dragElastic = _b.dragElastic, onDragEnd = _b.onDragEnd;\r\n        if (dragMomentum || dragElastic) {\r\n            var velocity = info.velocity;\r\n            this.animateDragEnd(velocity);\r\n        }\r\n        else {\r\n            this.recordBoxInfo(this.constraints);\r\n        }\r\n        onDragEnd && onDragEnd(event, convertPanToDrag(info, this.point));\r\n    };\r\n    ComponentDragControls.prototype.recordBoxInfo = function (constraints) {\r\n        if (constraints) {\r\n            var right = constraints.right, left = constraints.left, bottom = constraints.bottom, top_1 = constraints.top;\r\n            this.prevConstraintsBox.width = (right || 0) - (left || 0);\r\n            this.prevConstraintsBox.height = (bottom || 0) - (top_1 || 0);\r\n        }\r\n        if (this.point.x)\r\n            this.prevConstraintsBox.x = this.point.x.get();\r\n        if (this.point.y)\r\n            this.prevConstraintsBox.y = this.point.y.get();\r\n    };\r\n    ComponentDragControls.prototype.snapToCursor = function (event) {\r\n        var _this = this;\r\n        var transformPagePoint = this.props.transformPagePoint;\r\n        var point = extractEventInfo(event).point;\r\n        var boundingBox = getBoundingBox(this.ref, transformPagePoint);\r\n        var center = {\r\n            x: boundingBox.width / 2 + boundingBox.left + window.scrollX,\r\n            y: boundingBox.height / 2 + boundingBox.top + window.scrollY,\r\n        };\r\n        var offset = {\r\n            x: point.x - center.x,\r\n            y: point.y - center.y,\r\n        };\r\n        bothAxis(function (axis) {\r\n            var point = _this.point[axis];\r\n            if (!point)\r\n                return;\r\n            _this.origin[axis].set(point.get());\r\n        });\r\n        this.updatePoint(\"x\", offset);\r\n        this.updatePoint(\"y\", offset);\r\n    };\r\n    ComponentDragControls.prototype.setPoint = function (axis, value) {\r\n        this.point[axis] = value;\r\n    };\r\n    ComponentDragControls.prototype.updatePoint = function (axis, offset) {\r\n        var _a = this.props, drag = _a.drag, dragElastic = _a.dragElastic;\r\n        var axisPoint = this.point[axis];\r\n        // If we're not dragging this axis, do an early return.\r\n        if (!shouldDrag(axis, drag, this.currentDirection) || !axisPoint)\r\n            return;\r\n        var current = applyConstraints(axis, this.origin[axis].get() + offset[axis], this.constraints, dragElastic);\r\n        axisPoint.set(current);\r\n    };\r\n    ComponentDragControls.prototype.updateProps = function (_a) {\r\n        var _this = this;\r\n        var _b = _a.drag, drag = _b === void 0 ? false : _b, _c = _a.dragDirectionLock, dragDirectionLock = _c === void 0 ? false : _c, _d = _a.dragPropagation, dragPropagation = _d === void 0 ? false : _d, _e = _a.dragConstraints, dragConstraints = _e === void 0 ? false : _e, _f = _a.dragElastic, dragElastic = _f === void 0 ? true : _f, _g = _a.dragMomentum, dragMomentum = _g === void 0 ? true : _g, remainingProps = __rest(_a, [\"drag\", \"dragDirectionLock\", \"dragPropagation\", \"dragConstraints\", \"dragElastic\", \"dragMomentum\"]);\r\n        this.props = __assign({ drag: drag,\r\n            dragDirectionLock: dragDirectionLock,\r\n            dragPropagation: dragPropagation,\r\n            dragConstraints: dragConstraints,\r\n            dragElastic: dragElastic,\r\n            dragMomentum: dragMomentum }, remainingProps);\r\n        var _dragValueX = remainingProps._dragValueX, _dragValueY = remainingProps._dragValueY, dragOriginX = remainingProps.dragOriginX, dragOriginY = remainingProps.dragOriginY;\r\n        if (dragOriginX)\r\n            this.origin.x = dragOriginX;\r\n        if (dragOriginY)\r\n            this.origin.y = dragOriginY;\r\n        // Get the `MotionValue` for both draggable axes, or create them if they don't already\r\n        // exist on this component.\r\n        bothAxis(function (axis) {\r\n            if (!shouldDrag(axis, drag, _this.currentDirection))\r\n                return;\r\n            var defaultValue = axis === \"x\" ? _dragValueX : _dragValueY;\r\n            _this.setPoint(axis, defaultValue || _this.values.get(axis, 0));\r\n        });\r\n        // If `dragConstraints` is a React `ref`, we should resolve the constraints once the\r\n        // component has rendered.\r\n        this.constraintsNeedResolution = isRefObject(dragConstraints);\r\n        this.constraints = this.constraintsNeedResolution\r\n            ? this.constraints || false\r\n            : dragConstraints;\r\n    };\r\n    ComponentDragControls.prototype.applyConstraintsToPoint = function (constraints) {\r\n        var _this = this;\r\n        if (constraints === void 0) { constraints = this.constraints; }\r\n        return bothAxis(function (axis) {\r\n            var axisPoint = _this.point[axis];\r\n            axisPoint &&\r\n                !axisPoint.isAnimating() &&\r\n                applyConstraints(axis, axisPoint, constraints, 0);\r\n        });\r\n    };\r\n    ComponentDragControls.prototype.animateDragEnd = function (velocity) {\r\n        var _this = this;\r\n        var _a = this.props, drag = _a.drag, dragMomentum = _a.dragMomentum, dragElastic = _a.dragElastic, dragTransition = _a.dragTransition, _dragValueX = _a._dragValueX, _dragValueY = _a._dragValueY, _dragTransitionControls = _a._dragTransitionControls;\r\n        var momentumAnimations = bothAxis(function (axis) {\r\n            var _a;\r\n            if (!shouldDrag(axis, drag, _this.currentDirection)) {\r\n                return;\r\n            }\r\n            var transition = _this.constraints\r\n                ? getConstraints(axis, _this.constraints)\r\n                : {};\r\n            /**\r\n             * Overdamp the boundary spring if `dragElastic` is disabled. There's still a frame\r\n             * of spring animations so we should look into adding a disable spring option to `inertia`.\r\n             * We could do something here where we affect the `bounceStiffness` and `bounceDamping`\r\n             * using the value of `dragElastic`.\r\n             */\r\n            var bounceStiffness = dragElastic ? 200 : 1000000;\r\n            var bounceDamping = dragElastic ? 40 : 10000000;\r\n            var animationControls = _dragTransitionControls || _this.controls;\r\n            var inertia = __assign(__assign({ type: \"inertia\", velocity: dragMomentum ? velocity[axis] : 0, bounceStiffness: bounceStiffness,\r\n                bounceDamping: bounceDamping, timeConstant: 750, restDelta: 1 }, dragTransition), transition);\r\n            var externalAxisMotionValue = axis === \"x\" ? _dragValueX : _dragValueY;\r\n            // If we're not animating on an externally-provided `MotionValue` we can use the\r\n            // component's animation controls which will handle interactions with whileHover (etc),\r\n            // otherwise we just have to animate the `MotionValue` itself.\r\n            return externalAxisMotionValue\r\n                ? startAnimation(axis, externalAxisMotionValue, 0, inertia)\r\n                : animationControls.start((_a = {},\r\n                    _a[axis] = 0,\r\n                    _a.transition = inertia,\r\n                    _a));\r\n        });\r\n        // Run all animations and then resolve the new drag constraints.\r\n        return Promise.all(momentumAnimations).then(function () {\r\n            _this.recordBoxInfo(_this.constraints);\r\n            _this.scalePoint();\r\n            var onDragTransitionEnd = _this.props.onDragTransitionEnd;\r\n            onDragTransitionEnd && onDragTransitionEnd();\r\n        });\r\n    };\r\n    ComponentDragControls.prototype.scalePoint = function () {\r\n        var _this = this;\r\n        var _a = this.props, dragConstraints = _a.dragConstraints, transformPagePoint = _a.transformPagePoint;\r\n        if (!isRefObject(dragConstraints))\r\n            return;\r\n        var constraintsBox = getBoundingBox(dragConstraints, transformPagePoint);\r\n        var draggableBox = getBoundingBox(this.ref, transformPagePoint);\r\n        // Scale a point relative to the transformation of a constraints-providing element.\r\n        var scaleAxisPoint = function (axis, dimension) {\r\n            var pointToScale = _this.point[axis];\r\n            if (!pointToScale)\r\n                return;\r\n            // Stop any current animations as they bug out if you resize during one\r\n            if (pointToScale.isAnimating()) {\r\n                pointToScale.stop();\r\n                _this.recordBoxInfo();\r\n                return;\r\n            }\r\n            // If the previous dimension was `0` (default), set `scale` to `1` to prevent\r\n            // divide by zero errors.\r\n            var scale = _this.prevConstraintsBox[dimension]\r\n                ? (constraintsBox[dimension] - draggableBox[dimension]) /\r\n                    _this.prevConstraintsBox[dimension]\r\n                : 1;\r\n            pointToScale.set(_this.prevConstraintsBox[axis] * scale);\r\n        };\r\n        scaleAxisPoint(\"x\", \"width\");\r\n        scaleAxisPoint(\"y\", \"height\");\r\n    };\r\n    ComponentDragControls.prototype.mount = function (element) {\r\n        var _this = this;\r\n        var stopPointerListener = addPointerEvent(element, \"pointerdown\", function (event) {\r\n            var _a = _this.props, drag = _a.drag, _b = _a.dragListener, dragListener = _b === void 0 ? true : _b;\r\n            drag && dragListener && _this.start(event);\r\n        });\r\n        var stopResizeListener = addDomEvent(window, \"resize\", function () {\r\n            return _this.scalePoint();\r\n        });\r\n        if (this.constraintsNeedResolution) {\r\n            var _a = this.props, dragConstraints = _a.dragConstraints, transformPagePoint = _a.transformPagePoint;\r\n            var constraints = calculateConstraintsFromDom(dragConstraints, this.ref, this.point, transformPagePoint);\r\n            this.applyConstraintsToPoint(constraints);\r\n            this.recordBoxInfo(constraints);\r\n        }\r\n        else if (!this.isDragging && this.constraints) {\r\n            this.applyConstraintsToPoint();\r\n        }\r\n        return function () {\r\n            stopPointerListener && stopPointerListener();\r\n            stopResizeListener && stopResizeListener();\r\n            _this.cancelDrag();\r\n        };\r\n    };\r\n    return ComponentDragControls;\r\n}());\r\n// Call a handler once for each axis\r\nfunction bothAxis(handler) {\r\n    return [handler(\"x\"), handler(\"y\")];\r\n}\r\nfunction convertPanToDrag(info, point) {\r\n    return __assign(__assign({}, info), { point: {\r\n            x: point.x ? point.x.get() : 0,\r\n            y: point.y ? point.y.get() : 0,\r\n        } });\r\n}\r\nfunction getConstraints(axis, _a) {\r\n    var top = _a.top, right = _a.right, bottom = _a.bottom, left = _a.left;\r\n    if (axis === \"x\") {\r\n        return { min: left, max: right };\r\n    }\r\n    else {\r\n        return { min: top, max: bottom };\r\n    }\r\n}\r\nfunction shouldDrag(direction, drag, currentDirection) {\r\n    return ((drag === true || drag === direction) &&\r\n        (currentDirection === null || currentDirection === direction));\r\n}\r\n/**\r\n * Based on an x/y offset determine the current drag direction. If both axis' offsets are lower\r\n * than the provided threshold, return `null`.\r\n *\r\n * @param offset - The x/y offset from origin.\r\n * @param lockThreshold - (Optional) - the minimum absolute offset before we can determine a drag direction.\r\n */\r\nfunction getCurrentDirection(offset, lockThreshold) {\r\n    if (lockThreshold === void 0) { lockThreshold = 10; }\r\n    var direction = null;\r\n    if (Math.abs(offset.y) > lockThreshold) {\r\n        direction = \"y\";\r\n    }\r\n    else if (Math.abs(offset.x) > lockThreshold) {\r\n        direction = \"x\";\r\n    }\r\n    return direction;\r\n}\r\n/**\r\n * Takes a parent Element and a draggable Element and returns pixel-based drag constraints.\r\n *\r\n * @param constraintsRef\r\n * @param draggableRef\r\n */\r\nfunction calculateConstraintsFromDom(constraintsRef, draggableRef, point, transformPagePoint) {\r\n    invariant(constraintsRef.current !== null && draggableRef.current !== null, \"If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.\");\r\n    var parentBoundingBox = getBoundingBox(constraintsRef, transformPagePoint);\r\n    var draggableBoundingBox = getBoundingBox(draggableRef, transformPagePoint);\r\n    var left = parentBoundingBox.left -\r\n        draggableBoundingBox.left +\r\n        getCurrentOffset(point.x);\r\n    var top = parentBoundingBox.top -\r\n        draggableBoundingBox.top +\r\n        getCurrentOffset(point.y);\r\n    var right = parentBoundingBox.width - draggableBoundingBox.width + left;\r\n    var bottom = parentBoundingBox.height - draggableBoundingBox.height + top;\r\n    return { top: top, left: left, right: right, bottom: bottom };\r\n}\r\nfunction getBoundingBox(ref, transformPagePoint) {\r\n    var rect = ref.current.getBoundingClientRect();\r\n    var _a = transformPagePoint({\r\n        x: rect.left,\r\n        y: rect.top,\r\n    }), left = _a.x, top = _a.y;\r\n    var _b = transformPagePoint({\r\n        x: rect.width,\r\n        y: rect.height,\r\n    }), width = _b.x, height = _b.y;\r\n    return { left: left, top: top, width: width, height: height };\r\n}\r\nfunction getCurrentOffset(point) {\r\n    return point ? point.get() : 0;\r\n}\r\nfunction applyConstraints(axis, value, constraints, dragElastic) {\r\n    var constrainedValue = value instanceof MotionValue ? value.get() : value;\r\n    if (!constraints) {\r\n        return constrainedValue;\r\n    }\r\n    var _a = getConstraints(axis, constraints), min = _a.min, max = _a.max;\r\n    if (min !== undefined && constrainedValue < min) {\r\n        constrainedValue = dragElastic\r\n            ? applyOverdrag(min, constrainedValue, dragElastic)\r\n            : Math.max(min, constrainedValue);\r\n    }\r\n    else if (max !== undefined && constrainedValue > max) {\r\n        constrainedValue = dragElastic\r\n            ? applyOverdrag(max, constrainedValue, dragElastic)\r\n            : Math.min(max, constrainedValue);\r\n    }\r\n    if (value instanceof MotionValue) {\r\n        value.set(constrainedValue);\r\n    }\r\n    return constrainedValue;\r\n}\r\nfunction applyOverdrag(origin, current, dragElastic) {\r\n    var dragFactor = typeof dragElastic === \"number\" ? dragElastic : 0.35;\r\n    return mix(origin, current, dragFactor);\r\n}\n\n/**\r\n * A hook that allows an element to be dragged.\r\n *\r\n * @param param\r\n * @param ref\r\n * @param values\r\n * @param controls\r\n *\r\n * @internal\r\n */\r\nfunction useDrag(props, ref, values, controls) {\r\n    var groupDragControls = props.dragControls;\r\n    var transformPagePoint = useContext(MotionPluginContext).transformPagePoint;\r\n    var dragControls = useConstant(function () { return new ComponentDragControls({ ref: ref, values: values, controls: controls }); });\r\n    dragControls.updateProps(__assign(__assign({}, props), { transformPagePoint: transformPagePoint }));\r\n    useEffect(function () { return groupDragControls && groupDragControls.subscribe(dragControls); }, [dragControls]);\r\n    useEffect(function () { return dragControls.mount(ref.current); }, []);\r\n}\n\nvar Drag = {\r\n    key: \"drag\",\r\n    shouldRender: function (props) { return !!props.drag; },\r\n    Component: makeRenderlessComponent(function (_a) {\r\n        var innerRef = _a.innerRef, values = _a.values, controls = _a.controls, props = __rest(_a, [\"innerRef\", \"values\", \"controls\"]);\r\n        return useDrag(props, innerRef, values, controls);\r\n    }),\r\n};\n\nfunction isCSSVariable(value) {\r\n    return typeof value === \"string\" && value.startsWith(\"var(--\");\r\n}\r\n/**\r\n * Parse Framer's special CSS variable format into a CSS token and a fallback.\r\n *\r\n * ```\r\n * `var(--foo, #fff)` => [`--foo`, '#fff']\r\n * ```\r\n *\r\n * @param current\r\n */\r\nvar cssVariableRegex = /var\\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\\)/;\r\nfunction parseCSSVariable(current) {\r\n    var match = cssVariableRegex.exec(current);\r\n    if (!match)\r\n        return [,];\r\n    var token = match[1], fallback = match[2];\r\n    return [token, fallback];\r\n}\r\nvar maxDepth = 4;\r\nfunction getVariableValue(current, element, depth) {\r\n    if (depth === void 0) { depth = 1; }\r\n    invariant(depth <= maxDepth, \"Max CSS variable fallback depth detected in property \\\"\" + current + \"\\\". This may indicate a circular fallback dependency.\");\r\n    var _a = parseCSSVariable(current), token = _a[0], fallback = _a[1];\r\n    // No CSS variable detected\r\n    if (!token)\r\n        return;\r\n    // Attempt to read this CSS variable off the element\r\n    var resolved = window.getComputedStyle(element).getPropertyValue(token);\r\n    if (resolved) {\r\n        return resolved;\r\n    }\r\n    else if (isCSSVariable(fallback)) {\r\n        // The fallback might itself be a CSS variable, in which case we attempt to resolve it too.\r\n        return getVariableValue(fallback, element, depth + 1);\r\n    }\r\n    else {\r\n        return fallback;\r\n    }\r\n}\r\n/**\r\n * Resolve CSS variables from\r\n *\r\n * @internal\r\n */\r\nfunction resolveCSSVariables(values, ref, _a, transitionEnd) {\r\n    var target = __rest(_a, []);\r\n    var element = ref.current;\r\n    if (!(element instanceof HTMLElement))\r\n        return { target: target, transitionEnd: transitionEnd };\r\n    // If `transitionEnd` isn't `undefined`, clone it. We could clone `target` and `transitionEnd`\r\n    // only if they change but I think this reads clearer and this isn't a performance-critical path.\r\n    if (transitionEnd) {\r\n        transitionEnd = __assign({}, transitionEnd);\r\n    }\r\n    // Go through existing `MotionValue`s and ensure any existing CSS variables are resolved\r\n    values.forEach(function (value) {\r\n        var current = value.get();\r\n        if (!isCSSVariable(current))\r\n            return;\r\n        var resolved = getVariableValue(current, element);\r\n        if (resolved)\r\n            value.set(resolved);\r\n    });\r\n    // Cycle through every target property and resolve CSS variables. Currently\r\n    // we only read single-var properties like `var(--foo)`, not `calc(var(--foo) + 20px)`\r\n    for (var key in target) {\r\n        var current = target[key];\r\n        if (!isCSSVariable(current))\r\n            continue;\r\n        var resolved = getVariableValue(current, element);\r\n        if (!resolved)\r\n            continue;\r\n        // Clone target if it hasn't already been\r\n        target[key] = resolved;\r\n        // If the user hasn't already set this key on `transitionEnd`, set it to the unresolved\r\n        // CSS variable. This will ensure that after the animation the component will reflect\r\n        // changes in the value of the CSS variable.\r\n        if (transitionEnd && transitionEnd[key] === undefined) {\r\n            transitionEnd[key] = current;\r\n        }\r\n    }\r\n    return { target: target, transitionEnd: transitionEnd };\r\n}\n\nvar positionalKeys = new Set([\r\n    \"width\",\r\n    \"height\",\r\n    \"top\",\r\n    \"left\",\r\n    \"right\",\r\n    \"bottom\",\r\n    \"x\",\r\n    \"y\",\r\n]);\r\nvar isPositionalKey = function (key) { return positionalKeys.has(key); };\r\nvar hasPositionalKey = function (target) {\r\n    return Object.keys(target).some(isPositionalKey);\r\n};\r\nvar setAndResetVelocity = function (value, to) {\r\n    // Looks odd but setting it twice doesn't render, it'll just\r\n    // set both prev and current to the latest value\r\n    value.set(to, false);\r\n    value.set(to);\r\n};\r\nvar isNumOrPxType = function (v) {\r\n    return v === number || v === px;\r\n};\r\nvar BoundingBoxDimension;\r\n(function (BoundingBoxDimension) {\r\n    BoundingBoxDimension[\"width\"] = \"width\";\r\n    BoundingBoxDimension[\"height\"] = \"height\";\r\n    BoundingBoxDimension[\"left\"] = \"left\";\r\n    BoundingBoxDimension[\"right\"] = \"right\";\r\n    BoundingBoxDimension[\"top\"] = \"top\";\r\n    BoundingBoxDimension[\"bottom\"] = \"bottom\";\r\n})(BoundingBoxDimension || (BoundingBoxDimension = {}));\r\nvar getPosFromMatrix = function (matrix, pos) {\r\n    return parseFloat(matrix.split(\", \")[pos]);\r\n};\r\nvar getTranslateFromMatrix = function (pos2, pos3) { return function (_bbox, _a) {\r\n    var transform = _a.transform;\r\n    if (transform === \"none\" || !transform)\r\n        return 0;\r\n    var matrix3d = transform.match(/^matrix3d\\((.+)\\)$/);\r\n    if (matrix3d) {\r\n        return getPosFromMatrix(matrix3d[1], pos3);\r\n    }\r\n    else {\r\n        var matrix = transform.match(/^matrix\\((.+)\\)$/);\r\n        if (matrix) {\r\n            return getPosFromMatrix(matrix[1], pos2);\r\n        }\r\n        else {\r\n            return 0;\r\n        }\r\n    }\r\n}; };\r\nvar transformKeys = new Set([\"x\", \"y\", \"z\"]);\r\nvar nonTranslationalTransformKeys = transformProps.filter(function (key) { return !transformKeys.has(key); });\r\nfunction removeNonTranslationalTransform(values, elementStyler) {\r\n    var removedTransforms = [];\r\n    nonTranslationalTransformKeys.forEach(function (key) {\r\n        var value = values.get(key);\r\n        if (value !== undefined) {\r\n            removedTransforms.push([key, value.get()]);\r\n            value.set(key.startsWith(\"scale\") ? 1 : 0);\r\n        }\r\n    });\r\n    // Apply changes to element before measurement\r\n    if (removedTransforms.length)\r\n        elementStyler.render();\r\n    return removedTransforms;\r\n}\r\nvar positionalValues = {\r\n    // Dimensions\r\n    width: function (_a) {\r\n        var width = _a.width;\r\n        return width;\r\n    },\r\n    height: function (_a) {\r\n        var height = _a.height;\r\n        return height;\r\n    },\r\n    top: function (_bbox, _a) {\r\n        var top = _a.top;\r\n        return parseFloat(top);\r\n    },\r\n    left: function (_bbox, _a) {\r\n        var left = _a.left;\r\n        return parseFloat(left);\r\n    },\r\n    bottom: function (_a, _b) {\r\n        var height = _a.height;\r\n        var top = _b.top;\r\n        return parseFloat(top) + height;\r\n    },\r\n    right: function (_a, _b) {\r\n        var width = _a.width;\r\n        var left = _b.left;\r\n        return parseFloat(left) + width;\r\n    },\r\n    // Transform\r\n    x: getTranslateFromMatrix(4, 13),\r\n    y: getTranslateFromMatrix(5, 14),\r\n};\r\nvar convertChangedValueTypes = function (target, values, element, elementStyler, changedKeys) {\r\n    var originBbox = element.getBoundingClientRect();\r\n    var elementComputedStyle = getComputedStyle(element);\r\n    var display = elementComputedStyle.display, top = elementComputedStyle.top, left = elementComputedStyle.left, bottom = elementComputedStyle.bottom, right = elementComputedStyle.right, transform = elementComputedStyle.transform;\r\n    var originComputedStyle = { top: top, left: left, bottom: bottom, right: right, transform: transform };\r\n    // If the element is currently set to display: \"none\", make it visible before\r\n    // measuring the target bounding box\r\n    if (display === \"none\") {\r\n        elementStyler.set(\"display\", target.display || \"block\");\r\n    }\r\n    // Apply the latest values (as set in checkAndConvertChangedValueTypes)\r\n    elementStyler.render();\r\n    var targetBbox = element.getBoundingClientRect();\r\n    changedKeys.forEach(function (key) {\r\n        // Restore styles to their **calculated computed style**, not their actual\r\n        // originally set style. This allows us to animate between equivalent pixel units.\r\n        var value = values.get(key);\r\n        setAndResetVelocity(value, positionalValues[key](originBbox, originComputedStyle));\r\n        target[key] = positionalValues[key](targetBbox, elementComputedStyle);\r\n    });\r\n    return target;\r\n};\r\nvar checkAndConvertChangedValueTypes = function (values, ref, target, transitionEnd) {\r\n    if (transitionEnd === void 0) { transitionEnd = {}; }\r\n    target = __assign({}, target);\r\n    transitionEnd = __assign({}, transitionEnd);\r\n    var element = ref.current;\r\n    var elementStyler = styler(element);\r\n    var targetPositionalKeys = Object.keys(target).filter(isPositionalKey);\r\n    // We want to remove any transform values that could affect the element's bounding box before\r\n    // it's measured. We'll reapply these later.\r\n    var removedTransformValues = [];\r\n    var hasAttemptedToRemoveTransformValues = false;\r\n    var changedValueTypeKeys = targetPositionalKeys.reduce(function (acc, key) {\r\n        var value = values.get(key);\r\n        if (!value)\r\n            return acc;\r\n        var from = value.get();\r\n        var to = target[key];\r\n        var fromType = getDimensionValueType(from);\r\n        var toType;\r\n        // TODO: The current implementation of this basically throws an error\r\n        // if you try and do value conversion via keyframes. There's probably\r\n        // a way of doing this but the performance implications would need greater scrutiny,\r\n        // as it'd be doing multiple resize-remeasure operations.\r\n        if (isKeyframesTarget(to)) {\r\n            var numKeyframes = to.length;\r\n            for (var i = to[0] === null ? 1 : 0; i < numKeyframes; i++) {\r\n                if (!toType) {\r\n                    toType = getDimensionValueType(to[i]);\r\n                    invariant(toType === fromType ||\r\n                        (isNumOrPxType(fromType) &&\r\n                            isNumOrPxType(toType)), \"Keyframes must be of the same dimension as the current value\");\r\n                }\r\n                else {\r\n                    invariant(getDimensionValueType(to[i]) === toType, \"All keyframes must be of the same type\");\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            toType = getDimensionValueType(to);\r\n        }\r\n        if (fromType !== toType) {\r\n            // If they're both just number or px, convert them both to numbers rather than\r\n            // relying on resize/remeasure to convert (which is wasteful in this situation)\r\n            if (isNumOrPxType(fromType) && isNumOrPxType(toType)) {\r\n                var current = value.get();\r\n                if (typeof current === \"string\") {\r\n                    value.set(parseFloat(current));\r\n                }\r\n                if (typeof to === \"string\") {\r\n                    target[key] = parseFloat(to);\r\n                }\r\n                else if (Array.isArray(to) && toType === px) {\r\n                    target[key] = to.map(parseFloat);\r\n                }\r\n            }\r\n            else {\r\n                // If we're going to do value conversion via DOM measurements, we first\r\n                // need to remove non-positional transform values that could affect the bbox measurements.\r\n                if (!hasAttemptedToRemoveTransformValues) {\r\n                    removedTransformValues = removeNonTranslationalTransform(values, elementStyler);\r\n                    hasAttemptedToRemoveTransformValues = true;\r\n                }\r\n                acc.push(key);\r\n                transitionEnd[key] =\r\n                    transitionEnd[key] !== undefined\r\n                        ? transitionEnd[key]\r\n                        : target[key];\r\n                setAndResetVelocity(value, to);\r\n            }\r\n        }\r\n        return acc;\r\n    }, []);\r\n    if (changedValueTypeKeys.length) {\r\n        var convertedTarget = convertChangedValueTypes(target, values, element, elementStyler, changedValueTypeKeys);\r\n        // If we removed transform values, reapply them before the next render\r\n        if (removedTransformValues.length) {\r\n            removedTransformValues.forEach(function (_a) {\r\n                var key = _a[0], value = _a[1];\r\n                values.get(key).set(value);\r\n            });\r\n        }\r\n        // Reapply original values\r\n        elementStyler.render();\r\n        return { target: convertedTarget, transitionEnd: transitionEnd };\r\n    }\r\n    else {\r\n        return { target: target, transitionEnd: transitionEnd };\r\n    }\r\n};\r\n/**\r\n * Convert value types for x/y/width/height/top/left/bottom/right\r\n *\r\n * Allows animation between `'auto'` -> `'100%'` or `0` -> `'calc(50% - 10vw)'`\r\n *\r\n * @param values\r\n * @param ref\r\n * @param target\r\n * @param transitionEnd\r\n * @internal\r\n */\r\nfunction unitConversion(values, ref, target, transitionEnd) {\r\n    return hasPositionalKey(target)\r\n        ? checkAndConvertChangedValueTypes(values, ref, target, transitionEnd)\r\n        : { target: target, transitionEnd: transitionEnd };\r\n}\n\nvar parseDomVariant = function (values, ref) {\r\n    return function (target, transitionEnd) {\r\n        var resolved = resolveCSSVariables(values, ref, target, transitionEnd);\r\n        target = resolved.target;\r\n        transitionEnd = resolved.transitionEnd;\r\n        return unitConversion(values, ref, target, transitionEnd);\r\n    };\r\n};\n\nfunction useForceUpdate() {\r\n    var _a = useState(0), forcedRenderCount = _a[0], setForcedRenderCount = _a[1];\r\n    return useCallback(function () { return setForcedRenderCount(forcedRenderCount + 1); }, [\r\n        forcedRenderCount,\r\n    ]);\r\n}\n\nvar SyncLayoutContext = createContext(null);\r\n/**\r\n * When layout changes happen asynchronously to their instigating render (ie when exiting\r\n * children of `AnimatePresence` are removed), `SyncLayout` can wrap parent and sibling\r\n * components that need to animate as a result of this layout change.\r\n *\r\n * @motion\r\n *\r\n * ```jsx\r\n * const MyComponent = ({ isVisible }) => {\r\n *   return (\r\n *     <SyncLayout>\r\n *       <AnimatePresence>\r\n *         {isVisible && (\r\n *           <motion.div exit={{ opacity: 0 }} />\r\n *         )}\r\n *       </AnimatePresence>\r\n *       <motion.div positionTransition />\r\n *     </SyncLayout>\r\n *   )\r\n * }\r\n * ```\r\n *\r\n * @internalremarks\r\n *\r\n * The way this component works is by memoising a function and passing it down via context.\r\n * The function, when called, updates the local state, which is used to invalidate the\r\n * memoisation cache. A new function is called, performing a synced re-render of components\r\n * that are using the SyncLayoutContext.\r\n *\r\n * @internal\r\n */\r\nvar UnstableSyncLayout = function (_a) {\r\n    var children = _a.children;\r\n    var forceUpdate = useForceUpdate();\r\n    return (createElement(SyncLayoutContext.Provider, { value: forceUpdate }, children));\r\n};\n\nvar _a;\r\nvar StepName;\r\n(function (StepName) {\r\n    StepName[\"Prepare\"] = \"prepare\";\r\n    StepName[\"Read\"] = \"read\";\r\n    StepName[\"Render\"] = \"render\";\r\n})(StepName || (StepName = {}));\r\nvar stepOrder = [StepName.Prepare, StepName.Read, StepName.Render];\r\nvar jobs = stepOrder.reduce(function (acc, key) {\r\n    acc[key] = [];\r\n    return acc;\r\n}, {});\r\nvar jobsNeedProcessing = false;\r\nfunction flushCallbackList(list) {\r\n    var numJobs = list.length;\r\n    for (var i = 0; i < numJobs; i++) {\r\n        list[i]();\r\n    }\r\n    list.length = 0;\r\n}\r\nfunction flushAllJobs() {\r\n    if (!jobsNeedProcessing)\r\n        return;\r\n    flushCallbackList(jobs.prepare);\r\n    flushCallbackList(jobs.read);\r\n    flushCallbackList(jobs.render);\r\n    jobsNeedProcessing = false;\r\n}\r\n// Note: The approach of schedulng jobs during the render step is incompatible with concurrent mode\r\n// where multiple renders might happen without a DOM update. This would result in unneccessary batched\r\n// jobs. But this was already a problem with our previous approach to positionTransition.\r\n// Hopefully the React team offer a getSnapshotBeforeUpdate-esque hook and we can move to that.\r\nvar createUseSyncEffect = function (stepName) { return function (callback) {\r\n    if (!callback)\r\n        return;\r\n    jobsNeedProcessing = true;\r\n    jobs[stepName].push(callback);\r\n}; };\r\nvar layoutSync = (_a = {},\r\n    _a[StepName.Prepare] = createUseSyncEffect(StepName.Prepare),\r\n    _a[StepName.Read] = createUseSyncEffect(StepName.Read),\r\n    _a[StepName.Render] = createUseSyncEffect(StepName.Render),\r\n    _a.flush = flushAllJobs,\r\n    _a);\n\nfunction isHTMLElement(element) {\r\n    return element instanceof HTMLElement;\r\n}\n\nvar defaultLayoutTransition = {\r\n    duration: 0.8,\r\n    ease: [0.45, 0.05, 0.19, 1.0],\r\n};\r\nvar defaultPositionTransition = underDampedSpring();\r\nfunction getDefaultLayoutTransition(isPositionOnly) {\r\n    return isPositionOnly ? defaultPositionTransition : defaultLayoutTransition;\r\n}\r\nfunction isResolver(transition) {\r\n    return typeof transition === \"function\";\r\n}\r\nvar axisLabels = {\r\n    x: {\r\n        id: \"x\",\r\n        size: \"width\",\r\n        min: \"left\",\r\n        max: \"right\",\r\n        origin: \"originX\",\r\n    },\r\n    y: {\r\n        id: \"y\",\r\n        size: \"height\",\r\n        min: \"top\",\r\n        max: \"bottom\",\r\n        origin: \"originY\",\r\n    },\r\n};\r\nfunction centerOf(min, max) {\r\n    return (min + max) / 2;\r\n}\r\nfunction calcAxisDelta(prev, next, names) {\r\n    var _a;\r\n    var sizeDelta = prev[names.size] - next[names.size];\r\n    var origin = 0.5;\r\n    // If the element has changed size we want to check whether either side is in\r\n    // the same position before/after the layout transition. If so, we can anchor\r\n    // the element to that position and only animate its size.\r\n    if (sizeDelta) {\r\n        if (prev[names.min] === next[names.min]) {\r\n            origin = 0;\r\n        }\r\n        else if (prev[names.max] === next[names.max]) {\r\n            origin = 1;\r\n        }\r\n    }\r\n    var delta = (_a = {},\r\n        _a[names.size] = sizeDelta,\r\n        _a[names.origin] = origin,\r\n        _a[names.id] = \r\n        // Only measure a position delta if we haven't anchored to one side\r\n        origin === 0.5\r\n            ? centerOf(prev[names.min], prev[names.max]) -\r\n                centerOf(next[names.min], next[names.max])\r\n            : 0,\r\n        _a);\r\n    return delta;\r\n}\r\nfunction calcDelta(prev, next) {\r\n    var delta = __assign(__assign({}, calcAxisDelta(prev, next, axisLabels.x)), calcAxisDelta(prev, next, axisLabels.y));\r\n    return delta;\r\n}\r\nvar offset = {\r\n    getLayout: function (_a) {\r\n        var offset = _a.offset;\r\n        return offset;\r\n    },\r\n    measure: function (element) {\r\n        var offsetLeft = element.offsetLeft, offsetTop = element.offsetTop, offsetWidth = element.offsetWidth, offsetHeight = element.offsetHeight;\r\n        return {\r\n            left: offsetLeft,\r\n            top: offsetTop,\r\n            right: offsetLeft + offsetWidth,\r\n            bottom: offsetTop + offsetHeight,\r\n            width: offsetWidth,\r\n            height: offsetHeight,\r\n        };\r\n    },\r\n};\r\nvar boundingBox = {\r\n    getLayout: function (_a) {\r\n        var boundingBox = _a.boundingBox;\r\n        return boundingBox;\r\n    },\r\n    measure: function (element) {\r\n        var _a = element.getBoundingClientRect(), left = _a.left, top = _a.top, width = _a.width, height = _a.height, right = _a.right, bottom = _a.bottom;\r\n        return { left: left, top: top, width: width, height: height, right: right, bottom: bottom };\r\n    },\r\n};\r\nfunction readPositionStyle(element) {\r\n    return window.getComputedStyle(element).position;\r\n}\r\nfunction getLayoutType(prev, next, isPositionOnly) {\r\n    return isPositionOnly && prev === next ? offset : boundingBox;\r\n}\r\nfunction isSizeKey(key) {\r\n    return key === \"width\" || key === \"height\";\r\n}\r\nfunction getTransition(_a) {\r\n    var layoutTransition = _a.layoutTransition, positionTransition = _a.positionTransition;\r\n    return layoutTransition || positionTransition;\r\n}\r\nvar LayoutAnimation = /** @class */ (function (_super) {\r\n    __extends(LayoutAnimation, _super);\r\n    function LayoutAnimation() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    // Measure the current state of the DOM before it's updated, and schedule checks to see\r\n    // if it's changed as a result of a React render.\r\n    LayoutAnimation.prototype.getSnapshotBeforeUpdate = function () {\r\n        var _a = this.props, innerRef = _a.innerRef, positionTransition = _a.positionTransition, values = _a.values, controls = _a.controls;\r\n        var element = innerRef.current;\r\n        if (!isHTMLElement(element))\r\n            return;\r\n        var layoutTransition = getTransition(this.props);\r\n        var isPositionOnly = !!positionTransition;\r\n        var positionStyle = readPositionStyle(element);\r\n        var prev = {\r\n            offset: offset.measure(element),\r\n            boundingBox: boundingBox.measure(element),\r\n        };\r\n        var transform;\r\n        var next;\r\n        var compare;\r\n        // We split the unsetting, read and reapplication of the `transform` style prop into\r\n        // different steps via useSyncEffect. Multiple components might all be doing the same\r\n        // thing and by splitting these jobs and flushing them in batches we prevent layout thrashing.\r\n        layoutSync.prepare(function () {\r\n            // Unset the transform of all layoutTransition components so we can accurately measure\r\n            // the target bounding box\r\n            transform = element.style.transform;\r\n            element.style.transform = \"\";\r\n        });\r\n        layoutSync.read(function () {\r\n            // Read the target VisualInfo of all layoutTransition components\r\n            next = {\r\n                offset: offset.measure(element),\r\n                boundingBox: boundingBox.measure(element),\r\n            };\r\n            var nextPosition = readPositionStyle(element);\r\n            compare = getLayoutType(positionStyle, nextPosition, isPositionOnly);\r\n        });\r\n        layoutSync.render(function () {\r\n            // Reverse the layout delta of all newly laid-out layoutTransition components into their\r\n            // prev visual state and then animate them into their new one using transforms.\r\n            var prevLayout = compare.getLayout(prev);\r\n            var nextLayout = compare.getLayout(next);\r\n            var delta = calcDelta(prevLayout, nextLayout);\r\n            var hasAnyChanged = delta.x || delta.y || delta.width || delta.height;\r\n            if (!hasAnyChanged) {\r\n                // If layout hasn't changed, reapply the transform and get out of here.\r\n                transform && (element.style.transform = transform);\r\n                return;\r\n            }\r\n            styler(element).set({\r\n                originX: delta.originX,\r\n                originY: delta.originY,\r\n            });\r\n            syncRenderSession.open();\r\n            var target = {};\r\n            var transition = {};\r\n            var transitionDefinition = isResolver(layoutTransition)\r\n                ? layoutTransition({ delta: delta })\r\n                : layoutTransition;\r\n            function makeTransition(layoutKey, transformKey, targetValue, visualOrigin) {\r\n                // If this dimension hasn't changed, early return\r\n                var deltaKey = isSizeKey(layoutKey) ? layoutKey : transformKey;\r\n                if (!delta[deltaKey])\r\n                    return;\r\n                var baseTransition = typeof transitionDefinition === \"boolean\"\r\n                    ? __assign({}, getDefaultLayoutTransition(isPositionOnly)) : transitionDefinition;\r\n                var value = values.get(transformKey, targetValue);\r\n                var velocity = value.getVelocity();\r\n                transition[transformKey] = baseTransition[transformKey]\r\n                    ? __assign({}, baseTransition[transformKey]) : __assign({}, baseTransition);\r\n                if (transition[transformKey].velocity === undefined) {\r\n                    transition[transformKey].velocity = velocity || 0;\r\n                }\r\n                // The target value of all transforms is the default value of that prop (ie x = 0, scaleX = 1)\r\n                // This is because we're inverting the layout change with `transform` and then animating to `transform: none`\r\n                target[transformKey] = targetValue;\r\n                var offsetToApply = !isSizeKey(layoutKey) && compare === offset\r\n                    ? value.get()\r\n                    : 0;\r\n                value.set(visualOrigin + offsetToApply);\r\n            }\r\n            makeTransition(\"left\", \"x\", 0, delta.x);\r\n            makeTransition(\"top\", \"y\", 0, delta.y);\r\n            if (!isPositionOnly) {\r\n                makeTransition(\"width\", \"scaleX\", 1, prev.boundingBox.width / next.boundingBox.width);\r\n                makeTransition(\"height\", \"scaleY\", 1, prev.boundingBox.height / next.boundingBox.height);\r\n            }\r\n            target.transition = transition;\r\n            // Only start the transition if `transitionDefinition` isn't `false`. Otherwise we want\r\n            // to leave the values in their newly-inverted state and let the user cope with the rest.\r\n            transitionDefinition && controls.start(target);\r\n            // Force a render to ensure there's no visual flickering\r\n            syncRenderSession.flush();\r\n        });\r\n        return null;\r\n    };\r\n    LayoutAnimation.prototype.componentDidUpdate = function () {\r\n        layoutSync.flush();\r\n    };\r\n    LayoutAnimation.prototype.render = function () {\r\n        return null;\r\n    };\r\n    LayoutAnimation.contextType = SyncLayoutContext;\r\n    return LayoutAnimation;\r\n}(Component));\r\nvar Layout = {\r\n    key: \"layout\",\r\n    shouldRender: function (_a) {\r\n        var positionTransition = _a.positionTransition, layoutTransition = _a.layoutTransition;\r\n        invariant(!(positionTransition && layoutTransition), \"Don't set both positionTransition and layoutTransition on the same component\");\r\n        return (typeof window !== \"undefined\" &&\r\n            !!(positionTransition || layoutTransition));\r\n    },\r\n    Component: LayoutAnimation,\r\n};\n\n/**\r\n * A list of all valid MotionProps\r\n *\r\n * @internalremarks\r\n * This doesn't throw if a `MotionProp` name is missing - it should.\r\n */\r\nvar validMotionProps = new Set([\r\n    \"initial\",\r\n    \"animate\",\r\n    \"exit\",\r\n    \"style\",\r\n    \"variants\",\r\n    \"transition\",\r\n    \"transformTemplate\",\r\n    \"transformValues\",\r\n    \"custom\",\r\n    \"inherit\",\r\n    \"static\",\r\n    \"positionTransition\",\r\n    \"layoutTransition\",\r\n    \"onAnimationStart\",\r\n    \"onAnimationComplete\",\r\n    \"onUpdate\",\r\n    \"onDragStart\",\r\n    \"onDrag\",\r\n    \"onDragEnd\",\r\n    \"onDirectionLock\",\r\n    \"onDragTransitionEnd\",\r\n    \"drag\",\r\n    \"dragControls\",\r\n    \"dragListener\",\r\n    \"dragConstraints\",\r\n    \"dragDirectionLock\",\r\n    \"dragElastic\",\r\n    \"dragMomentum\",\r\n    \"dragPropagation\",\r\n    \"dragTransition\",\r\n    \"_dragValueX\",\r\n    \"_dragValueY\",\r\n    \"_dragTransitionControls\",\r\n    \"dragOriginX\",\r\n    \"dragOriginY\",\r\n    \"onPan\",\r\n    \"onPanStart\",\r\n    \"onPanEnd\",\r\n    \"onPanSessionStart\",\r\n    \"onTap\",\r\n    \"onTapStart\",\r\n    \"onTapCancel\",\r\n    \"whileHover\",\r\n    \"whileTap\",\r\n    \"onHoverEnd\",\r\n    \"onHoverStart\",\r\n]);\r\n/**\r\n * Check whether a prop name is a valid `MotionProp` key.\r\n *\r\n * @param key - Name of the property to check\r\n * @returns `true` is key is a valid `MotionProp`.\r\n *\r\n * @public\r\n */\r\nfunction isValidMotionProp(key) {\r\n    return validMotionProps.has(key);\r\n}\n\nvar AnimatePropType;\r\n(function (AnimatePropType) {\r\n    AnimatePropType[\"Target\"] = \"Target\";\r\n    AnimatePropType[\"VariantLabel\"] = \"VariantLabel\";\r\n    AnimatePropType[\"AnimationSubscription\"] = \"AnimationSubscription\";\r\n})(AnimatePropType || (AnimatePropType = {}));\n\nfunction shallowCompare(next, prev) {\r\n    if (prev === null)\r\n        return false;\r\n    var prevLength = prev.length;\r\n    if (prevLength !== next.length)\r\n        return false;\r\n    for (var i = 0; i < prevLength; i++) {\r\n        if (prev[i] !== next[i])\r\n            return false;\r\n    }\r\n    return true;\r\n}\n\nvar hasUpdated = function (prev, next) {\r\n    return (next !== undefined &&\r\n        (Array.isArray(prev) && Array.isArray(next)\r\n            ? !shallowCompare(next, prev)\r\n            : prev !== next));\r\n};\r\nfunction targetWithoutTransition(_a, mergeTransitionEnd) {\r\n    if (mergeTransitionEnd === void 0) { mergeTransitionEnd = false; }\r\n    var transition = _a.transition, transitionEnd = _a.transitionEnd, target = __rest(_a, [\"transition\", \"transitionEnd\"]);\r\n    return mergeTransitionEnd\r\n        ? __assign(__assign({}, target), transitionEnd)\r\n        : target;\r\n}\r\n/**\r\n * Handle the `animate` prop when its an object of values, ie:\r\n *\r\n * ```jsx\r\n * <motion.div animate={{ opacity: 1 }} />\r\n * ```\r\n *\r\n * @internalremarks\r\n * It might be worth consolidating this with `use-variants`\r\n *\r\n * ```jsx\r\n * <motion.div animate=\"visible\" />\r\n * ```\r\n *\r\n * @param target\r\n * @param controls\r\n * @param values\r\n * @param transition\r\n *\r\n * @internal\r\n */\r\nfunction useAnimateProp(targetAndTransition, controls, values, defaultTransition) {\r\n    var isInitialRender = useRef(true);\r\n    var prevValues = useRef(null);\r\n    if (!prevValues.current) {\r\n        prevValues.current = targetWithoutTransition(targetAndTransition, true);\r\n    }\r\n    useEffect(function () {\r\n        var targetToAnimate = {};\r\n        // These are the values we're actually animating\r\n        var animatingTarget = targetWithoutTransition(targetAndTransition);\r\n        // This is the target as it'll be once transitionEnd values are applied\r\n        var finalTarget = targetWithoutTransition(targetAndTransition, true);\r\n        // Detect which values have changed between renders\r\n        for (var key in animatingTarget) {\r\n            // This value should animate on mount if this value doesn't already exist (wasn't\r\n            // defined in `style` or `initial`) or if it does exist and it's already changed.\r\n            var shouldAnimateOnMount = isInitialRender.current &&\r\n                (!values.has(key) ||\r\n                    values.get(key).get() !== finalTarget[key]);\r\n            // If this value has updated between renders or it's we're animating this value on mount,\r\n            // add it to the animate target.\r\n            var isValidValue = finalTarget[key] !== null;\r\n            var valueHasUpdated = hasUpdated(prevValues.current[key], finalTarget[key]);\r\n            if (isValidValue && (valueHasUpdated || shouldAnimateOnMount)) {\r\n                targetToAnimate[key] = animatingTarget[key];\r\n            }\r\n        }\r\n        isInitialRender.current = false;\r\n        prevValues.current = __assign(__assign({}, prevValues.current), finalTarget);\r\n        if (Object.keys(targetToAnimate).length) {\r\n            controls.start(__assign(__assign({}, targetToAnimate), { transition: targetAndTransition.transition || defaultTransition, transitionEnd: targetAndTransition.transitionEnd }));\r\n        }\r\n    }, [targetAndTransition]);\r\n}\n\nvar labelsToArray = function (label) {\r\n    if (!label) {\r\n        return [];\r\n    }\r\n    if (Array.isArray(label)) {\r\n        return label;\r\n    }\r\n    return [label];\r\n};\r\nvar resolveVariantLabels = function (variant) {\r\n    var unresolvedVariant = variant instanceof MotionValue ? variant.get() : variant;\r\n    return Array.from(new Set(labelsToArray(unresolvedVariant)));\r\n};\r\n/**\r\n * Hooks in React sometimes accept a dependency array as their final argument. (ie useEffect/useMemo)\r\n * When values in this array change, React re-runs the dependency. However if the array\r\n * contains a variable number of items, React throws an error.\r\n */\r\nvar asDependencyList = function (list) { return [\r\n    list.join(\",\"),\r\n]; };\n\nvar hasVariantChanged = function (oldVariant, newVariant) {\r\n    return oldVariant.join(\",\") !== newVariant.join(\",\");\r\n};\r\n/**\r\n * Handle variants and the `animate` prop when its set as variant labels.\r\n *\r\n * @param initial - Initial variant(s)\r\n * @param animate - Variant(s) to animate to\r\n * @param inherit - `true` is inheriting animations from parent\r\n * @param controls - Animation controls\r\n *\r\n * @internal\r\n */\r\nfunction useVariants(initial, animate, inherit, controls) {\r\n    var targetVariants = resolveVariantLabels(animate);\r\n    var context = useContext(MotionContext);\r\n    var parentAlreadyMounted = context.hasMounted && context.hasMounted.current;\r\n    var hasMounted = useRef(false);\r\n    useEffect(function () {\r\n        var shouldAnimate = false;\r\n        if (inherit) {\r\n            // If we're inheriting variant changes and the parent has already\r\n            // mounted when this component loads, we need to manually trigger\r\n            // this animation.\r\n            shouldAnimate = !!parentAlreadyMounted;\r\n            targetVariants = resolveVariantLabels(context.animate);\r\n        }\r\n        else {\r\n            shouldAnimate =\r\n                hasMounted.current ||\r\n                    hasVariantChanged(resolveVariantLabels(initial), targetVariants);\r\n        }\r\n        shouldAnimate && controls.start(targetVariants);\r\n        hasMounted.current = true;\r\n    }, asDependencyList(targetVariants));\r\n}\n\n/**\r\n * `useAnimationGroupSubscription` allows a component to subscribe to an\r\n * externally-created `AnimationControls`, created by the `useAnimation` hook.\r\n *\r\n * @param animation\r\n * @param controls\r\n *\r\n * @internal\r\n */\r\nfunction useAnimationGroupSubscription(animation, controls) {\r\n    var unsubscribe = useMemo(function () { return animation.subscribe(controls); }, [\r\n        animation,\r\n    ]);\r\n    useEffect(function () { return function () {\r\n        unsubscribe && unsubscribe();\r\n    }; }, [unsubscribe]);\r\n}\n\nvar _a$1, _b;\r\nvar AnimatePropComponents = (_a$1 = {},\r\n    _a$1[AnimatePropType.Target] = makeRenderlessComponent(function (_a) {\r\n        var animate = _a.animate, controls = _a.controls, values = _a.values, transition = _a.transition;\r\n        return useAnimateProp(animate, controls, values, transition);\r\n    }),\r\n    _a$1[AnimatePropType.VariantLabel] = makeRenderlessComponent(function (_a) {\r\n        var animate = _a.animate, _b = _a.inherit, inherit = _b === void 0 ? true : _b, controls = _a.controls, initial = _a.initial;\r\n        return useVariants(initial, animate, inherit, controls);\r\n    }),\r\n    _a$1[AnimatePropType.AnimationSubscription] = makeRenderlessComponent(function (_a) {\r\n        var animate = _a.animate, controls = _a.controls;\r\n        return useAnimationGroupSubscription(animate, controls);\r\n    }),\r\n    _a$1);\r\nvar isVariantLabel$1 = function (prop) {\r\n    return Array.isArray(prop) || typeof prop === \"string\";\r\n};\r\nvar isAnimationSubscription = function (_a) {\r\n    var animate = _a.animate;\r\n    return animate instanceof AnimationControls;\r\n};\r\nvar animationProps = [\"initial\", \"animate\", \"whileTap\", \"whileHover\"];\r\nvar animatePropTypeTests = (_b = {},\r\n    _b[AnimatePropType.Target] = function (props) {\r\n        return (props.animate !== undefined &&\r\n            !isVariantLabel$1(props.animate) &&\r\n            !isAnimationSubscription(props));\r\n    },\r\n    _b[AnimatePropType.VariantLabel] = function (props) {\r\n        return (props.variants !== undefined ||\r\n            animationProps.some(function (key) { return typeof props[key] === \"string\"; }));\r\n    },\r\n    _b[AnimatePropType.AnimationSubscription] = isAnimationSubscription,\r\n    _b);\r\nvar getAnimationComponent = function (props) {\r\n    var animatePropType = undefined;\r\n    for (var key in AnimatePropType) {\r\n        if (animatePropTypeTests[key](props)) {\r\n            animatePropType = key;\r\n        }\r\n    }\r\n    return animatePropType ? AnimatePropComponents[animatePropType] : undefined;\r\n};\n\n/**\r\n * When a component is the child of `AnimatePresence`, it can use `usePresence`\r\n * to access information about whether it's still present in the React tree.\r\n *\r\n * ```jsx\r\n * import { usePresence } from \"framer-motion\"\r\n *\r\n * export const Component = () => {\r\n *   const [isPresent, safeToRemove] = usePresence()\r\n *\r\n *   useEffect(() => {\r\n *     !isPresent setTimeout(safeToRemove, 1000)\r\n *   }, [isPresent])\r\n *\r\n *   return <div />\r\n * }\r\n * ```\r\n *\r\n * If `isPresent` is `false`, it means that a component has been removed the tree, but\r\n * `AnimatePresence` won't really remove it until `safeToRemove` has been called.\r\n *\r\n * @public\r\n */\r\nfunction usePresence() {\r\n    var context = useContext(PresenceContext);\r\n    if (context === null)\r\n        return [true];\r\n    var isPresent = context.isPresent, onExitComplete = context.onExitComplete, register = context.register;\r\n    useEffect(register, []);\r\n    return !isPresent && onExitComplete ? [false, onExitComplete] : [true];\r\n}\n\nvar Exit = {\r\n    key: \"exit\",\r\n    shouldRender: function (props) { return !!props.exit && !checkShouldInheritVariant(props); },\r\n    Component: makeRenderlessComponent(function (props) {\r\n        var _a;\r\n        var animate = props.animate, controls = props.controls, exit = props.exit;\r\n        var _b = usePresence(), isPresent = _b[0], onExitComplete = _b[1];\r\n        var presenceContext = useContext(PresenceContext);\r\n        var isPlayingExitAnimation = useRef(false);\r\n        var custom = ((_a = presenceContext) === null || _a === void 0 ? void 0 : _a.custom) !== undefined\r\n            ? presenceContext.custom\r\n            : props.custom;\r\n        useEffect(function () {\r\n            if (!isPresent) {\r\n                if (!isPlayingExitAnimation.current && exit) {\r\n                    controls.setProps(__assign(__assign({}, props), { custom: custom }));\r\n                    controls.start(exit).then(onExitComplete);\r\n                }\r\n                isPlayingExitAnimation.current = true;\r\n            }\r\n            else if (isPlayingExitAnimation.current &&\r\n                animate &&\r\n                !(animate instanceof AnimationControls)) {\r\n                controls.start(animate);\r\n            }\r\n            if (isPresent) {\r\n                isPlayingExitAnimation.current = false;\r\n            }\r\n        }, [isPresent]);\r\n    }),\r\n};\n\nvar isPropValid = function (key) { return !isValidMotionProp(key); };\r\n/**\r\n * Emotion and Styled Components both allow users to pass through arbitrary props to their components\r\n * to dynamically generate CSS. They both use the `@emotion/is-prop-valid` package to determine which\r\n * of these should be passed to the underlying DOM node.\r\n *\r\n * However, when styling a Motion component `styled(motion.div)`, both packages pass through *all* props\r\n * as it's seen as an arbitrary component rather than a DOM node. Motion only allows arbitrary props\r\n * passed through the `custom` prop so it doesn't *need* the payload or computational overhead of\r\n * `@emotion/is-prop-valid`, however to fix this problem we need to use it.\r\n *\r\n * By making it an optionalDependency we can offer this functionality only in the situations where it's\r\n * actually required.\r\n */\r\ntry {\r\n    var emotionIsPropValid_1 = require(\"@emotion/is-prop-valid\").default;\r\n    isPropValid = function (key) {\r\n        // Handle events explicitly as Emotion validates them all as true\r\n        if (key.startsWith(\"on\")) {\r\n            return !isValidMotionProp(key);\r\n        }\r\n        else {\r\n            return emotionIsPropValid_1(key);\r\n        }\r\n    };\r\n}\r\ncatch (_a) {\r\n    // We don't need to actually do anything here - the fallback is the existing `isPropValid`.\r\n}\r\nfunction filterValidProps(props) {\r\n    var domProps = {};\r\n    for (var key in props) {\r\n        if (isPropValid(key)) {\r\n            domProps[key] = props[key];\r\n        }\r\n    }\r\n    return domProps;\r\n}\r\nvar buildHTMLProps = function (values, style, isStatic, isDrag) {\r\n    // The `any` isn't ideal but it is the type of createElement props argument\r\n    var props = {\r\n        style: buildStyleAttr(values, style, isStatic),\r\n    };\r\n    if (isDrag) {\r\n        // Disable text selection\r\n        props.style.userSelect = \"none\";\r\n        // Disable the ghost element when a user drags\r\n        props.draggable = false;\r\n    }\r\n    return props;\r\n};\r\nvar buildSVGProps = function (values, style) {\r\n    var motionValueStyles = resolveCurrent(values);\r\n    var props = buildSVGAttrs(motionValueStyles, undefined, undefined, undefined, undefined, false);\r\n    props.style = __assign(__assign({}, style), props.style);\r\n    return props;\r\n};\r\nvar functionalityComponents = [Layout, Drag, Gestures, Exit];\r\nvar numFunctionalityComponents = functionalityComponents.length;\r\n/**\r\n * Create a configuration for `motion` components that provides DOM-specific functionality.\r\n *\r\n * @internal\r\n */\r\nfunction createDomMotionConfig(Component) {\r\n    var isDOM = typeof Component === \"string\";\r\n    var isSVG = isDOM && svgElements.indexOf(Component) !== -1;\r\n    return {\r\n        renderComponent: function (ref, style, values, props, isStatic) {\r\n            var forwardedProps = isDOM ? filterValidProps(props) : props;\r\n            var staticVisualStyles = isSVG\r\n                ? buildSVGProps(values, style)\r\n                : buildHTMLProps(values, style, isStatic, !!props.drag);\r\n            return createElement(Component, __assign(__assign(__assign({}, forwardedProps), { ref: ref }), staticVisualStyles));\r\n        },\r\n        /**\r\n         * loadFunctionalityComponents gets used by the `motion` component\r\n         *\r\n         * Each functionality component gets provided the `ref`, animation controls and the `MotionValuesMap`\r\n         * generated for that component, as well as all the `props` passed to it by the user.\r\n         *\r\n         * The pattern used to determine whether to load and use each piece of functionality is\r\n         * consistent (should render? Then push component) and could be used to extend functionality.\r\n         *\r\n         * By exposing a mutable piece of memory via an API like `extendMotionComponent` we could\r\n         * allow users to add `FunctionalComponentDefinition`s. This would allow us to offer file size\r\n         * reductions by shipping an entry point that doesn't load gesture and drag functionality, and\r\n         * also offer a way for users to develop plugins/other functionality. Because these functionalities\r\n         * are loaded as components, we can look into using Suspense for this purpose.\r\n         *\r\n         * For user-defined functionality we'd need to allow\r\n         *  1) User-defined prop typing (extending `P`)\r\n         *  2) User-defined \"clean props\" function that removes their plugin's props before being passed to the DOM.\r\n         */\r\n        loadFunctionalityComponents: function (ref, values, props, context, controls, inherit) {\r\n            var activeComponents = [];\r\n            // TODO: Consolidate Animation functionality loading strategy with other functionality components\r\n            var Animation = getAnimationComponent(props);\r\n            if (Animation) {\r\n                activeComponents.push(createElement(Animation, { key: \"animation\", initial: props.initial, animate: props.animate, variants: props.variants, transition: props.transition, controls: controls, inherit: inherit, values: values }));\r\n            }\r\n            for (var i = 0; i < numFunctionalityComponents; i++) {\r\n                var _a = functionalityComponents[i], shouldRender = _a.shouldRender, key = _a.key, Component_1 = _a.Component;\r\n                if (shouldRender(props, context)) {\r\n                    activeComponents.push(createElement(Component_1, __assign({ key: key }, props, { parentContext: context, values: values, controls: controls, innerRef: ref })));\r\n                }\r\n            }\r\n            return activeComponents;\r\n        },\r\n        getValueControlsConfig: function (ref, values) {\r\n            return {\r\n                values: values,\r\n                readValueFromSource: function (key) {\r\n                    return styler(ref.current).get(key);\r\n                },\r\n                // TODO: This is a good second source of plugins. This function contains the CSS variable\r\n                // and unit conversion support. These functions share a common signature. We could make another\r\n                // API for adding these.\r\n                makeTargetAnimatable: parseDomVariant(values, ref),\r\n            };\r\n        },\r\n    };\r\n}\n\nvar htmlMotionComponents = htmlElements.reduce(function (acc, Component) {\r\n    var config = createDomMotionConfig(Component);\r\n    // Suppress \"Expression produces a union type that is too complex to represent\" error\r\n    // @ts-ignore\r\n    acc[Component] = createMotionComponent(config);\r\n    return acc;\r\n}, {});\r\nvar svgMotionComponents = svgElements.reduce(function (acc, Component) {\r\n    // Suppress \"Expression produces a union type that is too complex to represent\" error\r\n    // @ts-ignore\r\n    acc[Component] = createMotionComponent(createDomMotionConfig(Component));\r\n    return acc;\r\n}, {});\r\n/**\r\n * HTML & SVG components, optimised for use with gestures and animation. These can be used as\r\n * drop-in replacements for any HTML & SVG component, all CSS & SVG properties are supported.\r\n *\r\n * @internalremarks\r\n *\r\n * I'd like to make it possible for these to be loaded \"on demand\" - to reduce bundle size by only\r\n * including HTML/SVG stylers, animation and/or gesture support when necessary.\r\n *\r\n * ```jsx\r\n * <motion.div animate={{ x: 100 }} />\r\n *\r\n * <motion.p animate={{ height: 200 }} />\r\n *\r\n * <svg><motion.circle r={10} animate={{ r: 20 }} /></svg>\r\n * ```\r\n *\r\n * @public\r\n */\r\nvar motion = __assign(__assign({ \r\n    /**\r\n     * Convert a custom React component into a `motion` component.\r\n     *\r\n     * It can also accept a string, to create [custom DOM elements](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements).\r\n     *\r\n     * ```jsx\r\n     * const Component = React.forwardRef((props: Props, ref) => {\r\n     *   return <div ref={ref} />\r\n     * })\r\n     *\r\n     * const MotionComponent = motion.custom<Props>(Component)\r\n     * ```\r\n     *\r\n     * @param Component -\r\n     */\r\n    custom: function custom(Component) {\r\n        return createMotionComponent(createDomMotionConfig(Component));\r\n    } }, htmlMotionComponents), svgMotionComponents);\n\n/**\r\n * Creates a `MotionValue` to track the state and velocity of a value.\r\n *\r\n * Usually, these are created automatically. For advanced use-cases, like use with `useTransform`, you can create `MotionValue`s externally and pass them into the animated component via the `style` prop.\r\n *\r\n * @library\r\n *\r\n * ```jsx\r\n * export function MyComponent() {\r\n *   const scale = useMotionValue(1)\r\n *\r\n *   return <Frame scale={scale} />\r\n * }\r\n * ```\r\n *\r\n * @motion\r\n *\r\n * ```jsx\r\n * export const MyComponent = () => {\r\n *   const scale = useMotionValue(1)\r\n *\r\n *   return <motion.div style={{ scale }} />\r\n * }\r\n * ```\r\n *\r\n * @param initial - The initial state.\r\n *\r\n * @public\r\n */\r\nfunction useMotionValue(initial) {\r\n    return useConstant(function () { return motionValue(initial); });\r\n}\n\n/**\r\n * If the provided value is a MotionValue, this returns the actual value, otherwise just the value itself\r\n *\r\n * TODO: Remove and move to library\r\n *\r\n * @internal\r\n */\r\nfunction unwrapMotionValue(value) {\r\n    var unwrappedValue = value instanceof MotionValue ? value.get() : value;\r\n    return isCustomValue(unwrappedValue)\r\n        ? unwrappedValue.toValue()\r\n        : unwrappedValue;\r\n}\n\nvar isCustomValueType = function (v) {\r\n    return typeof v === \"object\" && v.mix;\r\n};\r\nvar getMixer = function (v) { return (isCustomValueType(v) ? v.mix : undefined); };\r\nfunction transform() {\r\n    var args = [];\r\n    for (var _i = 0; _i < arguments.length; _i++) {\r\n        args[_i] = arguments[_i];\r\n    }\r\n    var useImmediate = !Array.isArray(args[0]);\r\n    var argOffset = useImmediate ? 0 : -1;\r\n    var inputValue = args[0 + argOffset];\r\n    var inputRange = args[1 + argOffset];\r\n    var outputRange = args[2 + argOffset];\r\n    var options = args[3 + argOffset];\r\n    var interpolator = interpolate(inputRange, outputRange, __assign({ mixer: getMixer(outputRange[0]) }, options));\r\n    return useImmediate ? interpolator(inputValue) : interpolator;\r\n}\n\nvar isTransformer = function (v) {\r\n    return typeof v === \"function\";\r\n};\r\nvar noop$1 = function (v) { return v; };\r\nfunction useTransform(parent, customTransform, to, options) {\r\n    var value = useRef(null);\r\n    var comparitor = [parent];\r\n    var transformer = noop$1;\r\n    if (isTransformer(customTransform)) {\r\n        transformer = customTransform;\r\n    }\r\n    else if (Array.isArray(to)) {\r\n        var from = customTransform;\r\n        transformer = transform(from, to, options);\r\n        comparitor = [parent, from.join(\",\"), to.join(\",\")];\r\n    }\r\n    return useMemo(function () {\r\n        if (value.current)\r\n            value.current.destroy();\r\n        value.current = parent.addChild({ transformer: transformer });\r\n        return value.current;\r\n    }, comparitor);\r\n}\n\n// Keep things reasonable and avoid scale: Infinity. In practise we might need\r\n// to add another value, opacity, that could interpolate scaleX/Y [0,0.01] => [0,1]\r\n// to simply hide content at unreasonable scales.\r\nvar maxScale = 100000;\r\nvar invertScale = function (scale) { return (scale > 0.001 ? 1 / scale : maxScale); };\r\n/**\r\n * Returns a `MotionValue` each for `scaleX` and `scaleY` that update with the inverse\r\n * of their respective parent scales.\r\n *\r\n * This is useful for undoing the distortion of content when scaling a parent component.\r\n *\r\n * By default, `useInvertedScale` will automatically fetch `scaleX` and `scaleY` from the nearest parent.\r\n * By passing other `MotionValue`s in as `useInvertedScale({ scaleX, scaleY })`, it will invert the output\r\n * of those instead.\r\n *\r\n * @motion\r\n *\r\n * ```jsx\r\n * const MyComponent = () => {\r\n *   const { scaleX, scaleY } = useInvertedScale()\r\n *   return <motion.div style={{ scaleX, scaleY }} />\r\n * }\r\n * ```\r\n *\r\n * @library\r\n *\r\n * ```jsx\r\n * function MyComponent() {\r\n *   const { scaleX, scaleY } = useInvertedScale()\r\n *   return <Frame scaleX={scaleX} scaleY={scaleY} />\r\n * }\r\n * ```\r\n *\r\n * @public\r\n */\r\nfunction useInvertedScale(scale) {\r\n    var parentScaleX = useMotionValue(1);\r\n    var parentScaleY = useMotionValue(1);\r\n    var values = useContext(MotionContext).values;\r\n    invariant(!!(scale || values), \"If no scale values are provided, useInvertedScale must be used within a child of another motion component.\");\r\n    if (scale) {\r\n        parentScaleX = scale.scaleX || parentScaleX;\r\n        parentScaleY = scale.scaleY || parentScaleY;\r\n    }\r\n    else if (values) {\r\n        parentScaleX = values.get(\"scaleX\", 1);\r\n        parentScaleY = values.get(\"scaleY\", 1);\r\n    }\r\n    var scaleX = useTransform(parentScaleX, invertScale);\r\n    var scaleY = useTransform(parentScaleY, invertScale);\r\n    return { scaleX: scaleX, scaleY: scaleY };\r\n}\n\nfunction useOnChange(value, callback) {\r\n    useEffect(function () { return (isMotionValue(value) ? value.onChange(callback) : undefined); }, [value]);\r\n}\n\n/**\r\n * Creates a `MotionValue` that, when `set`, will use a spring animation to animate to its new state.\r\n *\r\n * It can either work as a stand-alone `MotionValue` by initialising it with a value, or as a subscriber\r\n * to another `MotionValue`.\r\n *\r\n * @remarks\r\n *\r\n * ```jsx\r\n * const x = useSpring(0, { stiffness: 300 })\r\n * const y = useSpring(x, { damping: 10 })\r\n * ```\r\n *\r\n * @param inputValue - `MotionValue` or number. If provided a `MotionValue`, when the input `MotionValue` changes, the created `MotionValue` will spring towards that value.\r\n * @param springConfig - Configuration options for the spring.\r\n * @returns `MotionValue`\r\n *\r\n * @public\r\n */\r\nfunction useSpring(source, config) {\r\n    if (config === void 0) { config = {}; }\r\n    var activeSpringAnimation = useRef(null);\r\n    var value = useMotionValue(isMotionValue(source) ? source.get() : source);\r\n    useMemo(function () {\r\n        return value.attach(function (v, set) {\r\n            if (activeSpringAnimation.current) {\r\n                activeSpringAnimation.current.stop();\r\n            }\r\n            activeSpringAnimation.current = spring(__assign({ from: value.get(), to: v, velocity: value.getVelocity() }, config)).start(set);\r\n            return value.get();\r\n        });\r\n    }, Object.values(config));\r\n    useOnChange(source, function (v) { return value.set(parseFloat(v)); });\r\n    return value;\r\n}\n\nvar scrollX = motionValue(0);\r\nvar scrollY = motionValue(0);\r\nvar scrollXProgress = motionValue(0);\r\nvar scrollYProgress = motionValue(0);\r\nvar setProgress = function (offset, maxOffset, value) {\r\n    value.set(!maxOffset || !offset ? 0 : offset / maxOffset);\r\n};\r\nvar hasEventListener = false;\r\nvar addScrollListener = function () {\r\n    hasEventListener = true;\r\n    if (typeof window === \"undefined\")\r\n        return;\r\n    var updateScrollValues = function () {\r\n        var xOffset = window.pageXOffset;\r\n        var yOffset = window.pageYOffset;\r\n        // Set absolute positions\r\n        scrollX.set(xOffset);\r\n        scrollY.set(yOffset);\r\n        // Set 0-1 progress\r\n        setProgress(xOffset, document.body.clientWidth - window.innerWidth, scrollXProgress);\r\n        setProgress(yOffset, document.body.clientHeight - window.innerHeight, scrollYProgress);\r\n    };\r\n    updateScrollValues();\r\n    window.addEventListener(\"resize\", updateScrollValues);\r\n    window.addEventListener(\"scroll\", updateScrollValues, { passive: true });\r\n};\r\nvar viewportMotionValues = {\r\n    scrollX: scrollX,\r\n    scrollY: scrollY,\r\n    scrollXProgress: scrollXProgress,\r\n    scrollYProgress: scrollYProgress,\r\n};\r\n/**\r\n * Provides `MotionValue`s that update when the viewport scrolls:\r\n *\r\n * - `scrollX` — Horizontal scroll distance in pixels.\r\n * - `scrollY` — Vertical scroll distance in pixels.\r\n * - `scrollXProgress` — Horizontal scroll progress between `0` and `1`.\r\n * - `scrollYProgress` — Vertical scroll progress between `0` and `1`.\r\n *\r\n * **Note:** If the returned scroll `MotionValue`s don't seem to be updating,\r\n * double check if the `body` tag styles are set to `width: 100%; height: 100%` or\r\n * similar, as this can break accurate measurement of viewport scroll.\r\n *\r\n * @library\r\n *\r\n * ```jsx\r\n * import * as React from \"react\"\r\n * import {\r\n *   Frame,\r\n *   useViewportScroll,\r\n *   useTransform\r\n * } from \"framer\"\r\n *\r\n * export function MyComponent() {\r\n *   const { scrollYProgress } = useViewportScroll()\r\n *   return <Frame scaleX={scrollYProgress} />\r\n * }\r\n * ```\r\n *\r\n * @motion\r\n *\r\n * ```jsx\r\n * export const MyComponent = () => {\r\n *   const { scrollYProgress } = useViewportScroll()\r\n *   return <motion.div style={{ scaleX: scrollYProgress }} />\r\n * }\r\n * ```\r\n *\r\n * @internalremarks\r\n * This isn't technically a hook yet, but in the future it might be nice\r\n * to accept refs to elements and add scroll listeners to those, which\r\n * may involve the use of lifecycle.\r\n *\r\n * @public\r\n */\r\nfunction useViewportScroll() {\r\n    if (!hasEventListener) {\r\n        addScrollListener();\r\n    }\r\n    return viewportMotionValues;\r\n}\n\n/**\r\n * Creates `AnimationControls`, which can be used to manually start, stop\r\n * and sequence animations on one or more components.\r\n *\r\n * The returned `AnimationControls` should be passed to the `animate` property\r\n * of the components you want to animate.\r\n *\r\n * These components can then be animated with the `start` method.\r\n *\r\n * @library\r\n *\r\n * ```jsx\r\n * import * as React from 'react'\r\n * import { Frame, useAnimation } from 'framer'\r\n *\r\n * export function MyComponent(props) {\r\n *    const controls = useAnimation()\r\n *\r\n *    controls.start({\r\n *        x: 100,\r\n *        transition: { duration: 0.5 },\r\n *    })\r\n *\r\n *    return <Frame animate={controls} />\r\n * }\r\n * ```\r\n *\r\n * @motion\r\n *\r\n * ```jsx\r\n * import * as React from 'react'\r\n * import { motion, useAnimation } from 'framer-motion'\r\n *\r\n * export function MyComponent(props) {\r\n *    const controls = useAnimation()\r\n *\r\n *    controls.start({\r\n *        x: 100,\r\n *        transition: { duration: 0.5 },\r\n *    })\r\n *\r\n *    return <motion.div animate={controls} />\r\n * }\r\n * ```\r\n *\r\n * @returns Animation controller with `start` and `stop` methods\r\n *\r\n * @public\r\n */\r\nfunction useAnimation() {\r\n    var animationControls = useConstant(function () { return new AnimationControls(); });\r\n    useEffect(function () {\r\n        animationControls.mount();\r\n        return function () { return animationControls.unmount(); };\r\n    }, []);\r\n    return animationControls;\r\n}\n\n/**\r\n * Experimental API.\r\n *\r\n * Makes an animated version of `useState`.\r\n *\r\n * @remarks\r\n *\r\n * When the returned state setter is called, values will be animated to their new target.\r\n *\r\n * This allows the animation of arbitrary React components.\r\n *\r\n * **Note:** When animating DOM components, it's always preferable to use the `animate` prop, as Framer\r\n * will bypass React's rendering cycle with one optimised for 60fps motion. This Hook is specifically\r\n * for animating props on arbitrary React components, or for animating text content.\r\n *\r\n * ```jsx\r\n * const [state, setState] = useAnimatedState({ percentage: 0 })\r\n *\r\n * return (\r\n *   <Graph\r\n *     percentage={state.percentage}\r\n *     onTap={() => setState({ percentage: 50 })}\r\n *   />\r\n * )\r\n * ```\r\n *\r\n * @internalremarks\r\n *\r\n * TODO:\r\n * - Make hook accept a typed version of Target that accepts any value (not just DOM values)\r\n * - Allow hook to accept single values. ie useAnimatedState(0)\r\n * - Allow providing MotionValues via initialState.\r\n *\r\n * @beta\r\n */\r\nfunction useAnimatedState(initialState) {\r\n    var _a = useState(initialState), animationState = _a[0], onUpdate = _a[1];\r\n    var config = useConstant(function () { return ({ onUpdate: onUpdate }); });\r\n    var values = useMotionValues(config);\r\n    var controls = useValueAnimationControls({\r\n        values: values,\r\n        readValueFromSource: function (key) { return animationState[key]; },\r\n    }, {}, false);\r\n    var startAnimation = useConstant(function () { return function (animationDefinition) {\r\n        return controls.start(animationDefinition);\r\n    }; });\r\n    useEffect(function () {\r\n        values.mount();\r\n        return function () { return values.unmount(); };\r\n    }, []);\r\n    return [animationState, startAnimation];\r\n}\n\n/**\r\n * Cycles through a series of visual properties. Can be used to toggle between or cycle through animations. It works similar to `useState` in React. It is provided an initial array of possible states, and returns an array of two arguments.\r\n *\r\n * @library\r\n *\r\n * ```jsx\r\n * import * as React from \"react\"\r\n * import { Frame, useCycle } from \"framer\"\r\n *\r\n * export function MyComponent() {\r\n *   const [x, cycleX] = useCycle(0, 50, 100)\r\n *\r\n *   return (\r\n *     <Frame\r\n *       animate={{ x: x }}\r\n *       onTap={() => cycleX()}\r\n *      />\r\n *    )\r\n * }\r\n * ```\r\n *\r\n * @motion\r\n *\r\n * An index value can be passed to the returned `cycle` function to cycle to a specific index.\r\n *\r\n * ```jsx\r\n * import * as React from \"react\"\r\n * import { motion, useCycle } from \"framer-motion\"\r\n *\r\n * export const MyComponent = () => {\r\n *   const [x, cycleX] = useCycle(0, 50, 100)\r\n *\r\n *   return (\r\n *     <motion.div\r\n *       animate={{ x: x }}\r\n *       onTap={() => cycleX()}\r\n *      />\r\n *    )\r\n * }\r\n * ```\r\n *\r\n * @param items - items to cycle through\r\n * @returns [currentState, cycleState]\r\n *\r\n * @public\r\n */\r\nfunction useCycle() {\r\n    var items = [];\r\n    for (var _i = 0; _i < arguments.length; _i++) {\r\n        items[_i] = arguments[_i];\r\n    }\r\n    // TODO: After Framer X beta, remove this warning\r\n    warning(items.length > 1, \"useCycle syntax has changed. `useCycle([0, 1, 2])` becomes `useCycle(0, 1, 2)`\");\r\n    var index = useRef(0);\r\n    var _a = useState(items[index.current]), item = _a[0], setItem = _a[1];\r\n    return [\r\n        item,\r\n        function (next) {\r\n            index.current =\r\n                typeof next !== \"number\"\r\n                    ? wrap(0, items.length, index.current + 1)\r\n                    : next;\r\n            setItem(items[index.current]);\r\n        },\r\n    ];\r\n}\n\n/**\r\n * Can manually trigger a drag gesture on one or more `drag`-enabled `motion` components.\r\n *\r\n * @library\r\n *\r\n * ```jsx\r\n * const dragControls = useDragControls()\r\n *\r\n * function startDrag(event) {\r\n *   dragControls.start(event, { snapToCursor: true })\r\n * }\r\n *\r\n * return (\r\n *   <>\r\n *     <Frame onTapStart={startDrag} />\r\n *     <Frame drag=\"x\" dragControls={dragControls} />\r\n *   </>\r\n * )\r\n * ```\r\n *\r\n * @motion\r\n *\r\n * ```jsx\r\n * const dragControls = useDragControls()\r\n *\r\n * function startDrag(event) {\r\n *   dragControls.start(event, { snapToCursor: true })\r\n * }\r\n *\r\n * return (\r\n *   <>\r\n *     <div onMouseDown={startDrag} />\r\n *     <motion.div drag=\"x\" dragControls={dragControls} />\r\n *   </>\r\n * )\r\n * ```\r\n *\r\n * @public\r\n */\r\nvar DragControls = /** @class */ (function () {\r\n    function DragControls() {\r\n        this.componentControls = new Set();\r\n    }\r\n    /**\r\n     * Subscribe a component's internal `ComponentDragControls` to the user-facing API.\r\n     *\r\n     * @internal\r\n     */\r\n    DragControls.prototype.subscribe = function (controls) {\r\n        var _this = this;\r\n        this.componentControls.add(controls);\r\n        return function () { return _this.componentControls.delete(controls); };\r\n    };\r\n    /**\r\n     * Start a drag gesture on every `motion` component that has this set of drag controls\r\n     * passed into it via the `dragControls` prop.\r\n     *\r\n     * ```jsx\r\n     * dragControls.start(e, {\r\n     *   snapToCursor: true\r\n     * })\r\n     * ```\r\n     *\r\n     * @param event - A mouse/touch/pointer event.\r\n     * @param options - Options\r\n     *\r\n     * @public\r\n     */\r\n    DragControls.prototype.start = function (event, options) {\r\n        this.componentControls.forEach(function (controls) {\r\n            controls.start(event.nativeEvent || event, options);\r\n        });\r\n    };\r\n    return DragControls;\r\n}());\r\nvar createDragControls = function () { return new DragControls(); };\r\n/**\r\n * Usually, dragging is initiated by pressing down on a `motion` component with a `drag` prop\r\n * and moving it. For some use-cases, for instance clicking at an arbitrary point on a video scrubber, we\r\n * might want to initiate that dragging from a different component than the draggable one.\r\n *\r\n * By creating a `dragControls` using the `useDragControls` hook, we can pass this into\r\n * the draggable component's `dragControls` prop. It exposes a `start` method\r\n * that can start dragging from pointer events on other components.\r\n *\r\n * @library\r\n *\r\n * ```jsx\r\n * const dragControls = useDragControls()\r\n *\r\n * function startDrag(event) {\r\n *   dragControls.start(event, { snapToCursor: true })\r\n * }\r\n *\r\n * return (\r\n *   <>\r\n *     <Frame onTapStart={startDrag} />\r\n *     <Frame drag=\"x\" dragControls={dragControls} />\r\n *   </>\r\n * )\r\n * ```\r\n *\r\n * @motion\r\n *\r\n * ```jsx\r\n * const dragControls = useDragControls()\r\n *\r\n * function startDrag(event) {\r\n *   dragControls.start(event, { snapToCursor: true })\r\n * }\r\n *\r\n * return (\r\n *   <>\r\n *     <div onMouseDown={startDrag} />\r\n *     <motion.div drag=\"x\" dragControls={dragControls} />\r\n *   </>\r\n * )\r\n * ```\r\n *\r\n * @public\r\n */\r\nfunction useDragControls() {\r\n    return useConstant(createDragControls);\r\n}\n\nvar PresenceChild = function (_a) {\r\n    var children = _a.children, initial = _a.initial, isPresent = _a.isPresent, onExitComplete = _a.onExitComplete, custom = _a.custom;\r\n    var numPresenceChildren = useRef(0);\r\n    var numExitComplete = useRef(0);\r\n    var context = {\r\n        initial: initial,\r\n        isPresent: isPresent,\r\n        custom: custom,\r\n        onExitComplete: function () {\r\n            numExitComplete.current++;\r\n            var allComplete = numExitComplete.current >= numPresenceChildren.current;\r\n            onExitComplete && allComplete && onExitComplete();\r\n        },\r\n    };\r\n    var register = useMemo(function () {\r\n        numExitComplete.current = 0;\r\n        return function () {\r\n            numPresenceChildren.current++;\r\n            return function () { return numPresenceChildren.current--; };\r\n        };\r\n    }, [isPresent]);\r\n    return (createElement(PresenceContext.Provider, { value: __assign(__assign({}, context), { register: register }) }, children));\r\n};\n\nfunction getChildKey(child) {\r\n    return child.key || \"\";\r\n}\r\nfunction updateChildLookup(children, allChildren) {\r\n    var seenChildren = process.env.NODE_ENV !== \"production\" ? new Set() : null;\r\n    children.forEach(function (child) {\r\n        var key = getChildKey(child);\r\n        if (process.env.NODE_ENV !== \"production\" && seenChildren) {\r\n            if (seenChildren.has(key)) {\r\n                console.warn(\"Children of AnimatePresence require unique keys. \\\"\" + key + \"\\\" is a duplicate.\");\r\n            }\r\n            seenChildren.add(key);\r\n        }\r\n        allChildren.set(key, child);\r\n    });\r\n}\r\nfunction onlyElements(children) {\r\n    var filtered = [];\r\n    // We use forEach here instead of map as map mutates the component key by preprending `.$`\r\n    Children.forEach(children, function (child) {\r\n        if (isValidElement(child))\r\n            filtered.push(child);\r\n    });\r\n    return filtered;\r\n}\r\n/**\r\n * `AnimatePresence` enables the animation of components that have been removed from the tree.\r\n *\r\n * When adding/removing more than a single child, every child **must** be given a unique `key` prop.\r\n *\r\n * @library\r\n *\r\n * Any `Frame` components that have an `exit` property defined will animate out when removed from\r\n * the tree.\r\n *\r\n * ```jsx\r\n * import { Frame, AnimatePresence } from 'framer'\r\n *\r\n * // As items are added and removed from `items`\r\n * export function Items({ items }) {\r\n *   return (\r\n *     <AnimatePresence>\r\n *       {items.map(item => (\r\n *         <Frame\r\n *           key={item.id}\r\n *           initial={{ opacity: 0 }}\r\n *           animate={{ opacity: 1 }}\r\n *           exit={{ opacity: 0 }}\r\n *         />\r\n *       ))}\r\n *     </AnimatePresence>\r\n *   )\r\n * }\r\n * ```\r\n *\r\n * You can sequence exit animations throughout a tree using variants.\r\n *\r\n * @motion\r\n *\r\n * Any `motion` components that have an `exit` property defined will animate out when removed from\r\n * the tree.\r\n *\r\n * ```jsx\r\n * import { motion, AnimatePresence } from 'framer-motion'\r\n *\r\n * export const Items = ({ items }) => (\r\n *   <AnimatePresence>\r\n *     {items.map(item => (\r\n *       <motion.div\r\n *         key={item.id}\r\n *         initial={{ opacity: 0 }}\r\n *         animate={{ opacity: 1 }}\r\n *         exit={{ opacity: 0 }}\r\n *       />\r\n *     ))}\r\n *   </AnimatePresence>\r\n * )\r\n * ```\r\n *\r\n * You can sequence exit animations throughout a tree using variants.\r\n *\r\n * If a child contains multiple `motion` components with `exit` props, it will only unmount the child\r\n * once all `motion` components have finished animating out. Likewise, any components using\r\n * `usePresence` all need to call `safeToRemove`.\r\n *\r\n * @public\r\n */\r\nvar AnimatePresence = function (_a) {\r\n    var children = _a.children, custom = _a.custom, _b = _a.initial, initial = _b === void 0 ? true : _b, onExitComplete = _a.onExitComplete, exitBeforeEnter = _a.exitBeforeEnter;\r\n    // We want to force a re-render once all exiting animations have finished. We\r\n    // either use a local forceUpdate function, or one from a parent context if it exists.\r\n    var localForceUpdate = useForceUpdate();\r\n    var contextForceUpdate = useContext(SyncLayoutContext);\r\n    var forceUpdate = contextForceUpdate || localForceUpdate;\r\n    var isInitialRender = useRef(true);\r\n    // Filter out any children that aren't ReactElements. We can only track ReactElements with a props.key\r\n    var filteredChildren = onlyElements(children);\r\n    // Keep a living record of the children we're actually rendering so we\r\n    // can diff to figure out which are entering and exiting\r\n    var presentChildren = useRef(filteredChildren);\r\n    // A lookup table to quickly reference components by key\r\n    var allChildren = useRef(new Map())\r\n        .current;\r\n    // A living record of all currently exiting components.\r\n    var exiting = useRef(new Set()).current;\r\n    updateChildLookup(filteredChildren, allChildren);\r\n    // If this is the initial component render, just deal with logic surrounding whether\r\n    // we play onMount animations or not.\r\n    if (isInitialRender.current) {\r\n        isInitialRender.current = false;\r\n        return (createElement(Fragment, null, filteredChildren.map(function (child) { return (createElement(PresenceChild, { key: getChildKey(child), isPresent: true, initial: initial ? undefined : false }, child)); })));\r\n    }\r\n    // If this is a subsequent render, deal with entering and exiting children\r\n    var childrenToRender = __spreadArrays(filteredChildren);\r\n    // Diff the keys of the currently-present and target children to update our\r\n    // exiting list.\r\n    var presentKeys = presentChildren.current.map(getChildKey);\r\n    var targetKeys = filteredChildren.map(getChildKey);\r\n    // Diff the present children with our target children and mark those that are exiting\r\n    var numPresent = presentKeys.length;\r\n    for (var i = 0; i < numPresent; i++) {\r\n        var key = presentKeys[i];\r\n        if (targetKeys.indexOf(key) === -1) {\r\n            exiting.add(key);\r\n        }\r\n        else {\r\n            // In case this key has re-entered, remove from the exiting list\r\n            exiting.delete(key);\r\n        }\r\n    }\r\n    // If we currently have exiting children, and we're deferring rendering incoming children\r\n    // until after all current children have exiting, empty the childrenToRender array\r\n    if (exitBeforeEnter && exiting.size) {\r\n        childrenToRender = [];\r\n    }\r\n    // Loop through all currently exiting components and clone them to overwrite `animate`\r\n    // with any `exit` prop they might have defined.\r\n    exiting.forEach(function (key) {\r\n        // If this component is actually entering again, early return\r\n        if (targetKeys.indexOf(key) !== -1)\r\n            return;\r\n        var child = allChildren.get(key);\r\n        if (!child)\r\n            return;\r\n        var insertionIndex = presentKeys.indexOf(key);\r\n        var onExit = function () {\r\n            exiting.delete(key);\r\n            // Remove this child from the present children\r\n            var removeIndex = presentChildren.current.findIndex(function (child) { return child.key === key; });\r\n            presentChildren.current.splice(removeIndex, 1);\r\n            // Defer re-rendering until all exiting children have indeed left\r\n            if (!exiting.size) {\r\n                presentChildren.current = filteredChildren;\r\n                forceUpdate();\r\n                onExitComplete && onExitComplete();\r\n            }\r\n        };\r\n        childrenToRender.splice(insertionIndex, 0, createElement(PresenceChild, { key: getChildKey(child), isPresent: false, onExitComplete: onExit, custom: custom }, child));\r\n    });\r\n    // Add `MotionContext` even to children that don't need it to ensure we're rendering\r\n    // the same tree between renders\r\n    childrenToRender = childrenToRender.map(function (child) {\r\n        var key = child.key;\r\n        return exiting.has(key) ? (child) : (createElement(PresenceChild, { key: getChildKey(child), isPresent: true }, child));\r\n    });\r\n    presentChildren.current = childrenToRender;\r\n    if (process.env.NODE_ENV !== \"production\" &&\r\n        exitBeforeEnter &&\r\n        childrenToRender.length > 1) {\r\n        console.warn(\"You're attempting to animate multiple children within AnimatePresence, but its exitBeforeEnter prop is set to true. This will lead to odd visual behaviour.\");\r\n    }\r\n    return (createElement(Fragment, null, exiting.size\r\n        ? childrenToRender\r\n        : childrenToRender.map(function (child) { return cloneElement(child); })));\r\n};\n\n// Does this device prefer reduced motion? Returns `null` server-side.\r\nvar prefersReducedMotion = motionValue(null);\r\nif (typeof window !== \"undefined\") {\r\n    if (window.matchMedia) {\r\n        var motionMediaQuery_1 = window.matchMedia(\"(prefers-reduced-motion)\");\r\n        var setReducedMotionPreferences = function () {\r\n            return prefersReducedMotion.set(motionMediaQuery_1.matches);\r\n        };\r\n        motionMediaQuery_1.addListener(setReducedMotionPreferences);\r\n        setReducedMotionPreferences();\r\n    }\r\n    else {\r\n        prefersReducedMotion.set(false);\r\n    }\r\n}\r\nfunction determineShouldReduceMotion(prefersReduced, isReducedMotion) {\r\n    return typeof isReducedMotion === \"boolean\"\r\n        ? isReducedMotion\r\n        : Boolean(prefersReduced);\r\n}\n\n/**\r\n * A hook that returns `true` if we should be using reduced motion based on the current device's Reduced Motion setting.\r\n *\r\n * This can be used to implement changes to your UI based on Reduced Motion. For instance, replacing motion-sickness inducing\r\n * `x`/`y` animations with `opacity`, disabling the autoplay of background videos, or turning off parallax motion.\r\n *\r\n * It will actively respond to changes and re-render your components with the latest setting.\r\n *\r\n * ```jsx\r\n * export function Sidebar({ isOpem }) {\r\n *   const shouldReduceMotion = useReducedMotion()\r\n *   const closedX = shouldReduceMotion ? 0 : \"-100%\"\r\n *\r\n *   return (\r\n *     <motion.div animate={{\r\n *       opacity: isOpen ? 1 : 0,\r\n *       x: isOpen ? 0 : closedX\r\n *     }} />\r\n *   )\r\n * }\r\n * ```\r\n *\r\n * @return boolean\r\n *\r\n * @public\r\n */\r\nfunction useReducedMotion() {\r\n    var isReducedMotion = useContext(MotionContext).isReducedMotion;\r\n    var _a = useState(determineShouldReduceMotion(prefersReducedMotion.get(), isReducedMotion)), shouldReduceMotion = _a[0], setShouldReduceMotion = _a[1];\r\n    useEffect(function () {\r\n        return prefersReducedMotion.onChange(function (v) {\r\n            setShouldReduceMotion(determineShouldReduceMotion(v, isReducedMotion));\r\n        });\r\n    }, [setShouldReduceMotion, isReducedMotion]);\r\n    return shouldReduceMotion;\r\n}\n\n/**\r\n * Define accessibility options for a tree. Can be used to force the tree into Reduced Motion mode,\r\n * or disable device detection.\r\n *\r\n * @internal\r\n */\r\nfunction ReducedMotion(_a) {\r\n    var children = _a.children, enabled = _a.enabled;\r\n    var context = useContext(MotionContext);\r\n    context = useMemo(function () { return (__assign(__assign({}, context), { isReducedMotion: enabled })); }, [enabled]);\r\n    return (createElement(MotionContext.Provider, { value: context }, children));\r\n}\n\nexport { AnimatePresence, AnimationControls, DragControls, MotionContext, MotionPluginContext, MotionPlugins, MotionValue, Point, ReducedMotion, UnstableSyncLayout, animationControls, createMotionComponent, isValidMotionProp, motion, motionValue, transform, unwrapMotionValue, useAnimatedState, useAnimation, useCycle, useDomEvent, useDragControls, useExternalRef, useGestures, useInvertedScale, useMotionValue, usePanGesture, usePresence, useReducedMotion, useSpring, useTapGesture, useTransform, useViewportScroll };\n"],"sourceRoot":""}